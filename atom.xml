<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PRIN BLOG</title>
  
  <subtitle>半吊子全栈开发者的日常</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://printempw.github.io/"/>
  <updated>2020-03-24T23:07:00.000Z</updated>
  <id>https://printempw.github.io/</id>
  
  <author>
    <name>printempw</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用 Google Analytics API 实现博客阅读量统计</title>
    <link href="https://printempw.github.io/google-analytics-api-page-views-counter/"/>
    <id>https://printempw.github.io/google-analytics-api-page-views-counter/</id>
    <published>2020-03-24T23:07:00.000Z</published>
    <updated>2020-03-24T23:07:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间，Google Analytics 给我发了封邮件，说二月份我的博客有 9.3K 的 UV。点进去看了看热门的文章，访问量最多的是「<a href="https://printempw.github.io/twitter-account-has-been-locked/">Twitter 账号被锁定是种怎样的体验</a>」（17 年的博文了……），其他比较高的还有以前写的教程「<a href="https://printempw.github.io/windows-terminal-setup-guide/">Windows Terminal 安装与配置指南</a>」「<a href="https://printempw.github.io/wsl-guide/">WSL 配置指北：打造 Windows 最强命令行</a>」，以及后起之秀「<a href="https://printempw.github.io/namebase-handshake-airdrop/">记一次 HNS 币空投薅 $500 羊毛的经历</a>」，很真实。</p><p>看着报表上的访问量排名，我突然一寻思，这白花花的数据都在眼前，那能不能利用 GA 里的这些数据，给博客加个访问计数、阅读量统计功能呢？</p><a id="more"></a><p>当然可以。</p><p>我 Google 了一下，事实上早就已经有人这么干过了：</p><ul><li><a href="https://ihomura.cn/2018/07/26/%E7%94%A8-Google-Analytics-API-%E4%B8%BA-hexo-%E5%8D%9A%E5%AE%A2%E5%8A%A0%E4%B8%8A%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1/" target="_blank" rel="noopener">用 Google Analytics API 为 hexo 博客加上阅读量统计 | 澪同学的博客</a></li><li><a href="https://liginc.co.jp/210735" target="_blank" rel="noopener">Google Analytics APIでPVを集計しよう【実装編】 | 東京のWeb制作会社LIG</a></li><li><a href="https://www.indiehackers.com/post/is-this-crazy-hit-counter-pulling-from-google-analytics-eae3cdc538" target="_blank" rel="noopener">Is this crazy? Hit counter pulling from Google Analytics</a></li></ul><p>既然 GA 有官方提供的 API，那事情就好办了。</p><h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><p>先说成果。我写了两个版本的程序，分别使用 Node.js 和 PHP 实现，都可以通过页面 URI 查询 PV 访问量，提供的 API 也是一样的。源码放在 GitHub 上：</p><ul><li>Node.js 版本：<a href="https://github.com/printempw/google-analytics-hit-counter" target="_blank" rel="noopener">printempw/google-analytics-hit-counter</a></li><li>PHP 版本：同一仓库的 <a href="https://github.com/printempw/google-analytics-hit-counter/tree/php" target="_blank" rel="noopener"><code>php</code></a> 分支</li></ul><p>部署之后，前端通过其提供的 API 获取 PV，具体效果可以参考本博客。</p><p>程序的具体使用方法这里就不多说了，README 上都有写。下面具体讲讲怎么使用 Google Analytics API 以及可能遇到的坑，希望对各位有所帮助。</p><h2 id="启用-API-与获取凭据"><a href="#启用-API-与获取凭据" class="headerlink" title="启用 API 与获取凭据"></a>启用 API 与获取凭据</h2><p>首先根据<a href="https://developers.google.com/analytics/devguides/reporting/core/v4/quickstart/service-py" target="_blank" rel="noopener">官方的教程</a>启用 Analytics Reporting API v4。</p><p>登录 Google 账号后打开 <a href="https://console.developers.google.com/start/api?id=analyticsreporting.googleapis.com&credential=client_key" target="_blank" rel="noopener">setup tool</a>：</p><p><img src="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2020/google-analytics-api-page-views-counter/google-developer-console-enable-api.png" srcset="/images/loading.jpg" data-srcset="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2020/google-analytics-api-page-views-counter/google-developer-console-enable-api.png" alt="google-developer-console-enable-api"></p><p>点击创建项目后（也可以使用现有项目），会自动跳转至凭据页面。</p><p>页面会引导你回答一些问题以确定要创建的凭据的类型（API 密钥、OAuth 或者是服务账号），在我们这个场景下（服务器端访问 Google API 而非用户端访问）应该使用服务账号类型的凭据。</p><p><img src="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2020/google-analytics-api-page-views-counter/google-api-add-credential.png" srcset="/images/loading.jpg" data-srcset="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2020/google-analytics-api-page-views-counter/google-api-add-credential.png" alt="google-api-add-credential"></p><p>角色选择 Service Account User，密钥类型选择 JSON，点继续后浏览器会下载一个 JSON 文件，里面就是服务账号的密钥了。记得妥善保存这个密钥文件，下面的操作都要用到它。</p><h2 id="安装相应语言的-API-库"><a href="#安装相应语言的-API-库" class="headerlink" title="安装相应语言的 API 库"></a>安装相应语言的 API 库</h2><p>Google 提供了很多编程语言的 API 支持库，封装简化了认证与请求的流程。具体支持的语言可以查看官方文档：<a href="https://developers.google.com/analytics/devguides/reporting/core/v4/libraries" target="_blank" rel="noopener">Client Libraries | Analytics Reporting API v4</a>。</p><p>Node.js</p><pre><code class="sh">npm install googleapis</code></pre><p>Python</p><pre><code class="sh">pip install --upgrade google-api-python-client</code></pre><p>PHP</p><pre><code class="sh">composer require google/apiclient</code></pre><h2 id="通过-API-查询-PV-数据"><a href="#通过-API-查询-PV-数据" class="headerlink" title="通过 API 查询 PV 数据"></a>通过 API 查询 PV 数据</h2><p>下面以 Node.js 为例进行说明（也有<a href="https://github.com/googleapis/google-api-nodejs-client/blob/master/samples/analyticsReporting/batchGet.js" target="_blank" rel="noopener">官方样例</a>）。</p><p>使用凭据创建认证 client：</p><pre><code class="typescript">// 省略了外层 async 和其他 importimport { google } from &#39;googleapis&#39;// 如果使用了服务账号以外的认证方式这里也要改const auth = new google.auth.GoogleAuth({  // 上面下载的密钥文件。除了直接给文件路径，也可以把  // 文件里的内容通过 credentials, projectId 等参数传进来  keyFile: path.join(__dirname, &#39;key.json&#39;),  // API 作用域，我们只需要访问 Analytics  scopes: &#39;https://www.googleapis.com/auth/analytics.readonly&#39;,})const client = await auth.getClient()const analyticsreporting = google.analyticsreporting({  version: &#39;v4&#39;,  auth: client,});</code></pre><p>构建请求查询 API：</p><pre><code class="typescript">const res = await analyticsreporting.reports.batchGet({  requestBody: {    reportRequests: [{      // 数据视图 ID，可以在 GA 的「管理 &gt; 数据视图设置」内查看      viewId: &#39;213856884&#39;,      dateRanges: [{        // 查询起始日期，设置一个足够久远的时间以统计所有数据        startDate: &#39;2010-01-01&#39;,        // 查询结束日期        endDate: &#39;today&#39;,      }],      // Metric，官方翻译是指标，可以理解为要获取的数据字段      // 可以指定多个 metric，比如 &#39;ga:avgTimeOnPage&#39;      metrics: [{        expression: &#39;ga:pageviews&#39;      }],      // Dimension，官方翻译是维度，我们用这个来过滤数据      // 这里使用页面路径，也可以通过 &#39;ga:pageTitle&#39; 按标题过滤      dimensions: [{        name: &#39;ga:pagePath&#39;      }],      // 维度过滤器，只返回页面 URI 以所给字符串开头的数据      dimensionFilterClauses: [{        filters: [{          &#39;dimensionName&#39;: &#39;ga:pagePath&#39;,          &#39;operator&#39;: &#39;BEGINS_WITH&#39;,          &#39;expressions&#39;: [&#39;/foo&#39;],        }, {          &#39;dimensionName&#39;: &#39;ga:pagePath&#39;,          &#39;operator&#39;: &#39;BEGINS_WITH&#39;,          &#39;expressions&#39;: [&#39;/bar&#39;],        }]      }],      // 按照页面浏览量降序排序      orderBys: [{        fieldName: &#39;ga:pageviews&#39;,        sortOrder: &#39;DESCENDING&#39;      }],    }]  }})</code></pre><p>其中 Metric 和 Dimension 的概念可能有点不好理解，可以参考官方 API 文档：</p><ul><li><a href="https://developers.google.com/analytics/devguides/reporting/core/v4/basics" target="_blank" rel="noopener">Creating a Report | Analytics Reporting API v4</a></li><li><a href="https://ga-dev-tools.appspot.com/dimensions-metrics-explorer/" target="_blank" rel="noopener">Dimensions &amp; Metrics Explorer - Google Analytics Demos &amp; Tools</a></li></ul><p>以查询我博客上最新两篇文章的 PV 为例，API 响应是这样的：</p><pre><code class="json">{  &quot;reports&quot;: [    {      &quot;columnHeader&quot;: {        &quot;dimensions&quot;: [          &quot;ga:pagePath&quot;        ],        &quot;metricHeader&quot;: {          &quot;metricHeaderEntries&quot;: [{            &quot;name&quot;: &quot;ga:pageviews&quot;,            &quot;type&quot;: &quot;INTEGER&quot;          }]        }      },      &quot;data&quot;: {        &quot;rows&quot;: [          {            &quot;dimensions&quot;: [              &quot;/short-domain-name-for-blog/&quot;            ],            &quot;metrics&quot;: [{              &quot;values&quot;: [                &quot;135&quot;              ]            }]          },          {            &quot;dimensions&quot;: [              &quot;/reverse-proxy-for-126-mail-pop-server/&quot;            ],            &quot;metrics&quot;: [{              &quot;values&quot;: [                &quot;76&quot;              ]            }]          }        ],        &quot;totals&quot;: [{ &quot;values&quot;: [&quot;211&quot;] }],        &quot;rowCount&quot;: 2,        &quot;minimums&quot;: [{ &quot;values&quot;: [&quot;76&quot;] }],        &quot;maximums&quot;: [{ &quot;values&quot;: [&quot;135&quot;] }]      }    }  ]}</code></pre><p>不得不说很复杂、很强大，更高级的用法有待各位挖掘。</p><h2 id="踩坑：Serverless-部署的可行性"><a href="#踩坑：Serverless-部署的可行性" class="headerlink" title="踩坑：Serverless 部署的可行性"></a>踩坑：Serverless 部署的可行性</h2><p>其实最开始，我是没打算部署到自己的服务器上的，想着要是能直接用 Serverless 解决<del>（白嫖免费版）</del>最好。然而折腾了一天，在 <a href="https://workers.cloudflare.com/" target="_blank" rel="noopener">CloudFlare Workers</a> 与 <a href="https://zeit.co/docs" target="_blank" rel="noopener">ZEIT Now</a> 上的尝试均以失败告终。</p><p>CloudFlare Workers 上遇到的问题是 CPU 执行时间超时（script exceeded time limit）。我排查了很长时间，甚至怀疑是 Google 的 Node.js 库没有用 fetch API 的问题，还把 Analytics API 请求的部分用原生 fetch 重写了一遍。结果最后发现是因为 Google 服务账号的鉴权用的是 JWT，HS256 的签名算法。你妈的，难怪啊！</p><p>如果在 API 请求中手动指定 HTTP 请求头 <code>Authorization: Bearer &lt;access token&gt;</code> 认证的话屁事没有一切正常，但要签发 token 的话就不行了，sad。</p><p>不过我还不死心，又去 ZEIT Now 平台写了个 lambda 试了一下。这次运行是可以正常运行了，我却发现了一个挺要命的问题：<strong>缓存</strong>。在我们这个场景下，缓存肯定是必要的。API Client 认证获得了 access token 要缓存，从 API 那查询拿到的数据也要缓存，不然总不能每次请求都重新签发 token、查询数据吧。</p><p>然而我翻遍了文档，也没找到适用于这些 Serveless 平台的缓存解决方案（内存缓存？生命周期不允许；文件缓存？不允许读写文件；NoSQL？我靠，那还得去别的地方弄个远程服务来），或许是应用场景不合适吧。</p><p>无奈之下，只好部署到自己的乞丐版 VPS 上了。白嫖计划泡汤，遗憾。</p><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>我捣鼓博客这几年以来，在阅读量统计上也花过一些心思：</p><ul><li><a href="https://printempw.github.io/add-page-view-counter-for-ghost-blog/">为 Ghost 博客添加页面访问计数器</a></li><li><a href="https://printempw.github.io/add-page-view-counter-for-hexo/">为 Hexo 博客添加页面访问计数器</a></li></ul><p>直接使用 GA 的数据作为阅读量展示，有其优势也有其局限性。优势是不用自己维护统计的后端了，一个 GA 统计代码就可以通吃，数据也比较一致。</p><p>不足之处我目前想到就是数据更新不及时（GA 本身的延迟和缓存），以及统计代码容易被浏览器屏蔽吧（可以使用 <a href="https://github.com/SukkaW/cloudflare-workers-async-google-analytics" target="_blank" rel="noopener">SukkaW/cloudflare-workers-async-google-analytics</a> 这类异步 GA 解决方案）。不过我的博客浏览量统计对时效性和准确度并不敏感，所以目前看来，直接使用 GA 的数据对我来说应该是最好的方案了。</p><p>另外这也是我第一次在实际项目中使用 TypeScript，体验确实很不错，类型提示和自动补全不要太爽。不过就这么一个小 API 常驻一个 Node 服务有点太占资源了，顶不住，所以我又拿 Lumen 写了个 PHP 的版本。</p><p>两边实现的 API 都是一样的，各位有需要的话可以自行选择。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间，Google Analytics 给我发了封邮件，说二月份我的博客有 9.3K 的 UV。点进去看了看热门的文章，访问量最多的是「&lt;a href=&quot;https://printempw.github.io/twitter-account-has-been-locked/&quot;&gt;Twitter 账号被锁定是种怎样的体验&lt;/a&gt;」（17 年的博文了……），其他比较高的还有以前写的教程「&lt;a href=&quot;https://printempw.github.io/windows-terminal-setup-guide/&quot;&gt;Windows Terminal 安装与配置指南&lt;/a&gt;」「&lt;a href=&quot;https://printempw.github.io/wsl-guide/&quot;&gt;WSL 配置指北：打造 Windows 最强命令行&lt;/a&gt;」，以及后起之秀「&lt;a href=&quot;https://printempw.github.io/namebase-handshake-airdrop/&quot;&gt;记一次 HNS 币空投薅 $500 羊毛的经历&lt;/a&gt;」，很真实。&lt;/p&gt;
&lt;p&gt;看着报表上的访问量排名，我突然一寻思，这白花花的数据都在眼前，那能不能利用 GA 里的这些数据，给博客加个访问计数、阅读量统计功能呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://printempw.github.io/categories/tech/"/>
    
    
      <category term="博客" scheme="https://printempw.github.io/tag/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>反向代理解决 Gmail 代收 126 邮箱出现 Connection timed out 的问题</title>
    <link href="https://printempw.github.io/reverse-proxy-for-126-mail-pop-server/"/>
    <id>https://printempw.github.io/reverse-proxy-for-126-mail-pop-server/</id>
    <published>2020-03-18T06:27:58.000Z</published>
    <updated>2020-03-18T06:27:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>我有很多个电子邮箱地址，并且都设置了转发或者代收到 Gmail 上，方便集中处理。其中看重实时性、邮件需要尽快处理的邮箱地址（比如 <a href="mailto:printempw@gmail.com">printempw#gmail.com</a>）是设置的自动转发规则，其他无关紧要的邮箱则是在 Gmail 上设置了 POP3 代收信（<a href="https://support.google.com/mail/answer/21289" target="_blank" rel="noopener">查收其他帐号的邮件</a>），一直用到现在也没什么问题。</p><p>然而前段时间我却突然发现，Gmail 里收不到网易 126 邮箱里的邮件了。</p><a id="more"></a><p>打开 Gmail 配置一看，报错如下：</p><pre><code class="plain">连接到pop.126.com时出现问题服务器返回错误：“Connection timed out: There may be a problem with the settings you added. Please contact your other email provider to verify the correct server name and port.”</code></pre><p><img src="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2020/reverse-proxy-for-126-mail-pop-server/pop-126-com-connection-timed-out.png" srcset="/images/loading.jpg" data-srcset="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2020/reverse-proxy-for-126-mail-pop-server/pop-126-com-connection-timed-out.png" alt="pop-126-com-connection-timed-out"></p><p>看来是 Gmail 用于收件的服务器无法连接至网易 126 邮箱的 POP3 服务器了。搜了一下，似乎 2011 年时就有过类似的问题（<a href="https://groups.google.com/forum/#!topic/fans/fvPR1BSmqWk" target="_blank" rel="noopener">#1</a>、<a href="https://cyq.me/744" target="_blank" rel="noopener">#2</a>）。虽然不知道为什么之前都正常，不过有理由怀疑是网易邮箱屏蔽了 Gmail 的代收服务器。</p><p>本来想改成自动转发的，却不知为何一直收不到手机验证码，只能暂时作罢。</p><p><img src="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2020/reverse-proxy-for-126-mail-pop-server/failed-to-set-126-mail-forwarding.png" srcset="/images/loading.jpg" data-srcset="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2020/reverse-proxy-for-126-mail-pop-server/failed-to-set-126-mail-forwarding.png" alt="failed-to-set-126-mail-forwarding"></p><p>然而等了一个多星期还是收不到验证码（搞什么鬼），只能另寻他法代收邮件了。</p><hr><p>既然网易的 POP3 服务器屏蔽了 Gmail，那我们要做的也很简单，找一台能正常访问网易 POP3 的服务器转发代理一下就可以了（也就是反向代理）。端口转发方面我用了 <a href="http://www.dest-unreach.org/socat/" target="_blank" rel="noopener">socat</a>，配合 systemd 服务实现守护进程。</p><p>首先在 VPS 上测试一下能否正常访问网易 POP3 服务器：</p><pre><code class="sh">nc pop.126.com 110</code></pre><p>一切正常的话可以看到 POP3 服务器的欢迎语：</p><pre><code class="plain">+OK Welcome to coremail Mail Pop3 Server (126coms)</code></pre><p>运行 socat 端口转发：</p><pre><code class="sh">socat -d -d TCP4-LISTEN:1110,reuseaddr,fork TCP4:pop.126.com:110</code></pre><p>其中 <code>-d -d</code> 参数表示调试信息的输出级别，<code>TCP4-LISTEN:1110</code> 即监听在本机的 <code>1110</code> 端口（Gmail 的 POP3 服务器端口设置只接受 110、143、993、995、1110 和 2221），<code>TCP4:pop.126.com:110</code> 表示转发至网易服务器。</p><p>在另一台机器上测试端口转发（记得修改防火墙规则放行端口）：</p><pre><code class="sh">nc &lt;address of vps&gt; 1110</code></pre><p>可以看到网易 POP3 服务器的欢迎语就 OK。</p><p>接下来修改 Gmail 上的代收设置：</p><ul><li>POP 服务器：VPS 的域名/IP 地址</li><li>端口：上面设置的监听端口</li><li>取消勾选「检索邮件时，始终使用安全连接(SSL)」</li></ul><p>这样 Gmail 就可以正常代收网易邮箱的邮件了。</p><blockquote><p>如果想要配置支持 SSL 的 POP3 反向代理，可以使用 Nginx 实现，参考：<a href="https://docs.nginx.com/nginx/admin-guide/mail-proxy/mail-proxy/" target="_blank" rel="noopener">Configuring NGINX as a Mail Proxy Server</a>。不过我这邮箱就是注册垃圾站用的，没什么重要内容，懒得折腾，还是直接转发非 SSL 端口算了。</p></blockquote><p>接下来添加 systemd 服务（可跳过）：</p><pre><code class="sh">sudo vim /etc/systemd/system/pop-proxy.service</code></pre><pre><code class="ini">[Unit]Description=Port forwarding for 126 Mail POP serverAfter=network.target[Service]Type=simpleUser=nobodyExecStart=/usr/bin/socat -d -d TCP4-LISTEN:1110,reuseaddr,fork TCP4:pop.126.com:110Restart=always[Install]WantedBy=multi-user.target</code></pre><p>启动服务 &amp; 设置开机启动：</p><pre><code class="sh">sudo systemctl start pop-proxysudo systemctl enable pop-proxy</code></pre><p>查看连接日志：</p><pre><code class="sh">journalctl -u pop-proxy</code></pre><p>- EOF -</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我有很多个电子邮箱地址，并且都设置了转发或者代收到 Gmail 上，方便集中处理。其中看重实时性、邮件需要尽快处理的邮箱地址（比如 &lt;a href=&quot;mailto:printempw@gmail.com&quot;&gt;printempw#gmail.com&lt;/a&gt;）是设置的自动转发规则，其他无关紧要的邮箱则是在 Gmail 上设置了 POP3 代收信（&lt;a href=&quot;https://support.google.com/mail/answer/21289&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;查收其他帐号的邮件&lt;/a&gt;），一直用到现在也没什么问题。&lt;/p&gt;
&lt;p&gt;然而前段时间我却突然发现，Gmail 里收不到网易 126 邮箱里的邮件了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://printempw.github.io/categories/tech/"/>
    
    
      <category term="记录" scheme="https://printempw.github.io/tag/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>博客短域名 printem.pw</title>
    <link href="https://printempw.github.io/short-domain-name-for-blog/"/>
    <id>https://printempw.github.io/short-domain-name-for-blog/</id>
    <published>2020-03-15T11:22:00.000Z</published>
    <updated>2020-03-15T11:22:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>前几天在 Twitter 上看到一个「<a href="https://github.com/timqian/chinese-independent-blogs" target="_blank" rel="noopener">中文独立博客列表</a>」，点进去观摩了一下大佬们，然而正当我准备关掉页面时，看到项目的 README 底部赫然写着：</p><pre><code class="markdown">## 什么是独立博客- 拥有自己的域名- 作者本人原创内容</code></pre><p>且不说这定义是否准确，我就琢磨，我这 <code>github.io</code>，配当独立博客不？</p><a id="more"></a><p>然后我看了下列表里的博客们，托管在 GitHub Pages 上的博客也不在少数，看来这个所谓的「自己的域名」也是包括 <code>printempw.github.io</code> 这类二级域名的，可能博客园、CSDN 那类的才不算吧。</p><p>使用自定义域名当然不是什么难事，就算是放在 GitHub Pages 上也只需要整个 CNAME 解析一下就行了。所以使用私有域名与否，和博客本身的水平肯定是没有必然联系的，Medium 这类公共写作平台上还有不少大神呢。</p><p>当然，私有域名也是个人品牌的一部分，这一点也很重要。一个狂拽炫酷屌的拉风域名（比如曾经的 <a href="http://t.tt" target="_blank" rel="noopener">t.tt</a>），肯定比我这种烂大街的二级域名得分要高。不过现在的我并不看重这些，毕竟博客还是以内容为重，其他的都是次要的。</p><hr><p>其实我这个博客以前就是用的私有域名，还<a href="https://printempw.github.io/about/#%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2">换过好几个</a>。那为什么后来改成现在这个毫无特色的 GitHub 二级域名了呢？</p><p>之前的博文里也有零星提到过，我这人有种特殊的情结，总是希望自己能在浩如烟海的 Internet 上留下些什么痕迹，证明我曾经来到过、享受过这个赛博空间，甚至为其做出过一些微小的贡献。</p><p>自建服务器、自有域名其实挺脆弱的，没有人照看的话，服务器不续费会被停机，域名不续费会被收回。如果真出了些什么意料之外的状况，辛辛苦苦搭建起来的东西可能就灰飞烟灭了，或者只留存在<a href="https://archive.org/" target="_blank" rel="noopener">互联网档案馆</a>中。</p><p>以我的感性来看，这是挺难过的一件事，我不希望这样。</p><p>雁过尚且留声，人生岂能无痕？</p><p>所以本博客上的所有资源全部托管在 GitHub、CloudFlare 这类可靠的免费服务上，只要这些公司不倒闭跑路要么停止免费服务，或者人类迎来天启现代文明全部嗝屁儿，我的博客应该可以在无人值守的情况下保持很长一段时间的可访问状态。</p><hr><p>不过当然，这些都是以防万一嘛，人不能总是盼着最坏的情况活着。</p><p>所以我寻思了一下，把 <strong><a href="https://printem.pw" target="_blank" rel="noopener">printem.pw</a></strong> 这个域名也反代到了这里（之前是 301 重定向）。如果你愿意，你也可以用这个短域名来访问我的博客（加上 TLD 正好是我的常用 ID，我还是挺满意这域名的，<del>虽然还是很难记</del>）。我的各种 bio 上的主页也是用的这个域名，看起来也比较拉风，<del>虽然还是很难记</del>。</p><p>不过主域名还是继续使用 <strong><a href="https://printempw.github.io">printempw.github.io</a></strong>，包括短域名上的页面也都通过 <a href="https://support.google.com/webmasters/answer/139066" target="_blank" rel="noopener">rel=canonical &lt;link&gt; 标记</a> 指向主域名了，所以搜索引擎上出现的结果肯定还是指向这个二级域名的，交换友链的朋友也请尽量使用主域名。</p><p>嗯，要说的就这些，破事水，完毕。🤞</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天在 Twitter 上看到一个「&lt;a href=&quot;https://github.com/timqian/chinese-independent-blogs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;中文独立博客列表&lt;/a&gt;」，点进去观摩了一下大佬们，然而正当我准备关掉页面时，看到项目的 README 底部赫然写着：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;markdown&quot;&gt;## 什么是独立博客

- 拥有自己的域名
- 作者本人原创内容&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;且不说这定义是否准确，我就琢磨，我这 &lt;code&gt;github.io&lt;/code&gt;，配当独立博客不？&lt;/p&gt;
    
    </summary>
    
    
      <category term="日常" scheme="https://printempw.github.io/categories/diary/"/>
    
    
      <category term="博客" scheme="https://printempw.github.io/tag/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>处理 Manjaro 19.0 升级中的软件包变更</title>
    <link href="https://printempw.github.io/deal-with-manjaro-19-package-changes/"/>
    <id>https://printempw.github.io/deal-with-manjaro-19-package-changes/</id>
    <published>2020-02-29T04:47:00.000Z</published>
    <updated>2020-02-29T04:47:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>看到这标题你可能会觉得奇怪，Manjaro 不是滚动更新的发行版吗？<code>pacman -Syu</code> 一下就完事儿了，这有什么好写的。</p><p>其实不然。就算你一路滚上来所有包都是最新版本，也不代表你机器上的软件包就和最新的 ISO 一致了。</p><a id="more"></a><p><img src="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2020/deal-with-manjaro-19-package-changes/manjaro-19-0-kyria.png" srcset="/images/loading.jpg" data-srcset="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2020/deal-with-manjaro-19-package-changes/manjaro-19-0-kyria.png" alt="manjaro-19-0-kyria"></p><p>在发行版的迭代中，软件包的增删、升级是常有的事。</p><ul><li>如果新版本中有软件包被删除了：这些包不会被自动删除，除非你手动移除；</li><li>如果新版本中新增了软件包：升级时不会自动安装这些包，除非你手动安装；</li><li>如果新版本中软件包被另一软件包替代了：保持原样，除非你手动替换；</li><li>如此种种。</li></ul><p>总的来说就是，rolling release != everything updated with latest release。</p><p>想来这也是很正常的处理，不然你东西用得好好的突然给你删了或者换成了其他的，本来卸载掉的软件升级完又给你装回来了，都挺不爽的。</p><p>所以虽然在滚动更新中大部分的软件包都已经更新到了最新版本，和 Manjaro 19.0 的 ISO 中一致，但还是有些新增的软件包是没有安装到系统里的。如果是 Arch 用户就基本不会有这方面的顾虑，毕竟几乎所有软件包都是自己安装的，升级了就是升级了，和 Manjaro 这种预装好一大票软件包的发行版不一样。</p><p><strong>那么要如何手动处理新版本中的软件包变更呢？</strong></p><p>在这里你可以找到 Manjaro 19.0 中完整的软件包列表：</p><p><a href="https://osdn.net/projects/manjaro/storage/gnome/19.0/manjaro-gnome-19.0-200224-linux54-pkgs.txt" target="_blank" rel="noopener">manjaro-gnome-19.0-200224-linux54-pkgs.txt</a></p><p>和本地的软件包列表比较一下（ref: <a href="https://forum.manjaro.org/t/manjaro-19-0-released-gnome-kde-xfce-architect/126010/31" target="_blank" rel="noopener">Manjaro Forum</a>）：</p><pre><code class="bash">comm -1 -3 &lt;(pacman -Q | cut -d&#39; &#39; -f1 | sort) &lt;(curl &quot;https://osdn.net/projects/manjaro/storage/gnome/19.0/manjaro-gnome-19.0-200224-linux54-pkgs.txt&quot; -L -o - | cut -d&#39; &#39; -f1 | sort)</code></pre><p>比如说我的机器上对比的结果是这样的：</p><pre><code class="plain">adwaita-maiadashempathyevolutionfarstreamfirefox-gnome-theme-maiagame-devices-udevgamemodegfbgraphgnome-mapsgnome-shell-extension-desktop-icons-nggnome-shell-extension-gamemodegnome-shell-extension-nightshellswitchergnome-shell-extension-nightthemeswitchergupnp-avhexchatintel-ucodejre8-openjdkjre8-openjdk-headlesskvantum-theme-matchamalib(...)manjaro-browser-settingsmanjaro-dynamic-wallpapermanjaro-gdm-theme-19.0manjaro-gnome-assets-19.0manjaro-gnome-extension-settings-19.0manjaro-gnome-settings-19.0rygelsteam-manjarotelepathy-farstreamtelepathy-logger</code></pre><p>其中 Empathy、Evolution、Hexchat、Steam 这些预装软件是我自己删掉的，游戏模式、自动切换夜间模式是 19.0 新增的功能，<code>gnome-shell-extension-desktop-icons-ng</code> 替换掉了原来的 <code>gnome-shell-extension-desktop-icons</code>（GNOME 桌面图标扩展，新 fork 支持与文件管理器互相拖放），等等。</p><p>对照列表自行安装需要的软件包即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看到这标题你可能会觉得奇怪，Manjaro 不是滚动更新的发行版吗？&lt;code&gt;pacman -Syu&lt;/code&gt; 一下就完事儿了，这有什么好写的。&lt;/p&gt;
&lt;p&gt;其实不然。就算你一路滚上来所有包都是最新版本，也不代表你机器上的软件包就和最新的 ISO 一致了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://printempw.github.io/categories/tech/"/>
    
    
      <category term="Linux" scheme="https://printempw.github.io/tag/Linux/"/>
    
      <category term="Manjaro" scheme="https://printempw.github.io/tag/Manjaro/"/>
    
  </entry>
  
  <entry>
    <title>Nautilus 添加 Open in Guake 右键菜单</title>
    <link href="https://printempw.github.io/nautilus-open-in-guake-terminal/"/>
    <id>https://printempw.github.io/nautilus-open-in-guake-terminal/</id>
    <published>2020-02-23T20:22:00.000Z</published>
    <updated>2020-02-23T20:22:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>自从前段时间开始使用 <a href="https://github.com/Guake/guake" target="_blank" rel="noopener">Guake</a> <del>挂科</del>后，这个下拉式的终端模拟器可谓是深得我心，基本上就没其他终端什么事儿了。快捷键呼之即来挥之即去，设置成半透明背景后呼出占半屏也不遮挡其他窗口，各方面都很优秀。</p><p>不过在 GNOME 桌面默认的 Nautilus 文件浏览器里，「在终端中打开」右键菜单打开的还是 GNOME Terminal，得想个办法把它改成「在 Guake 中打开」。</p><a id="more"></a><p>我的系统是 Manjaro Linux 19.0，下面的操作在其他发行版应该也大同小异。</p><hr><p>首先移除原来的「在终端中打开」右键菜单。从 Nautilus 3.14 版本开始，这个菜单变成了 <code>gnome-terminal</code> 软件包的一部分（所以没法自定义这个菜单打开的终端）。</p><pre><code class="plain">$ pacman -Ql gnome-terminal | grep nautilusgnome-terminal /usr/lib/nautilus/gnome-terminal /usr/lib/nautilus/extensions-3.0/gnome-terminal /usr/lib/nautilus/extensions-3.0/libterminal-nautilus.so</code></pre><p>所以把这个扩展移除就好（或者直接卸载 <code>gnome-terminal</code>）：</p><pre><code class="bash">sudo mv -vi /usr/lib/nautilus/extensions-3.0/libterminal-nautilus.so{,.bak}</code></pre><p>退出 Nautilus 使改动生效：</p><pre><code class="bash">nautilus -q</code></pre><p>为了添加自定义右键菜单，我们可以使用 <a href="https://gitlab.gnome.org/GNOME/filemanager-actions" target="_blank" rel="noopener">FileManager-Actions</a> 这个扩展（当然也有其他添加右键菜单的方法，不过用这个比较方便）：</p><pre><code class="bash">sudo pacman -S filemanager-actions</code></pre><p>打开 FileManager-Actions Configuration Tool 配置界面：</p><pre><code class="bash">fma-config-tool</code></pre><p>添加新动作，配置如下：</p><p><img src="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2020/nautilus-open-in-guake-terminal/fma-config-tool-action.png" srcset="/images/loading.jpg" data-srcset="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2020/nautilus-open-in-guake-terminal/fma-config-tool-action.png" alt="fma-config-tool-action"></p><p>「命令」选项卡中，路径与参数分别设置为：</p><pre><code>/usr/bin/guake--show -e &quot;cd %f&quot;</code></pre><p>如果希望在新的终端 Tab 中打开，可以设置参数：</p><pre><code>--show -n &#39;%f&#39;</code></pre><p>其他自定义参数请参见 Guake 文档。</p><p>打开「编辑 &gt; Preference」，取消勾选「Create a root ‘Nautilus-Actions’ menu」，不然默认会把所有动作都放在二级右键菜单里。</p><p>最后「文件 &gt; 保存」，重新打开 Nautilus 即可生效。</p><p><img src="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2020/nautilus-open-in-guake-terminal/nautilus-menu-open-in-guake.png" srcset="/images/loading.jpg" data-srcset="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2020/nautilus-open-in-guake-terminal/nautilus-menu-open-in-guake.png" alt="nautilus-menu-open-in-guake"></p><p><strong>参考链接：</strong></p><ul><li><a href="https://askubuntu.com/questions/827838/can-i-remove-the-open-in-terminal-menu-item-from-nautilus/967154" target="_blank" rel="noopener">Can I remove the “open in terminal” menu item from nautilus? - Ask Ubuntu</a></li><li><a href="https://blog.csdn.net/zhanghm1995/article/details/89419109" target="_blank" rel="noopener">Ubuntu16.04或Ubuntu18.04设置右键打开terminator而非系统terminal</a></li><li><a href="https://askubuntu.com/questions/152193/how-to-open-directory-in-guake-from-nautilus" target="_blank" rel="noopener">How to open directory in Guake from Nautilus - Ask Ubuntu</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自从前段时间开始使用 &lt;a href=&quot;https://github.com/Guake/guake&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Guake&lt;/a&gt; &lt;del&gt;挂科&lt;/del&gt;后，这个下拉式的终端模拟器可谓是深得我心，基本上就没其他终端什么事儿了。快捷键呼之即来挥之即去，设置成半透明背景后呼出占半屏也不遮挡其他窗口，各方面都很优秀。&lt;/p&gt;
&lt;p&gt;不过在 GNOME 桌面默认的 Nautilus 文件浏览器里，「在终端中打开」右键菜单打开的还是 GNOME Terminal，得想个办法把它改成「在 Guake 中打开」。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://printempw.github.io/categories/tech/"/>
    
    
      <category term="Linux" scheme="https://printempw.github.io/tag/Linux/"/>
    
      <category term="终端" scheme="https://printempw.github.io/tag/%E7%BB%88%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>记一次 HNS 币空投薅 $500 羊毛的经历</title>
    <link href="https://printempw.github.io/namebase-handshake-airdrop/"/>
    <id>https://printempw.github.io/namebase-handshake-airdrop/</id>
    <published>2020-02-20T18:30:00.000Z</published>
    <updated>2020-02-20T18:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>没想到我人生中第一次 Cryptocurrency 实操经验，竟然是白嫖出来的。</p><a id="more"></a><p>昨天刷 Twitter 的时候，看到这样一条推文：</p><blockquote><p>白撸 700刀的 BTC 🤣 <a href="https://t.me/zuoluotvofficial/111" target="_blank" rel="noopener">https://t.me/zuoluotvofficial/111</a><br>如果满足下面这两个条件</p><ol><li>Github 账号在 2019-02-04 的时候超过 15 个粉丝</li><li>Github 在 2019-02-04 之前上传过 SSH &amp; PGP keys<br>亲测成功，猝不及防，白撸一台iPhone</li></ol><p>(Twitter <a href="https://twitter.com/luoleiorg/status/1230046924134207488" target="_blank" rel="noopener">@luoleiorg</a>)</p></blockquote><p>我当时就寻思，还有这种好事？天上掉馅饼，事出反常必有妖啊。</p><p>但这位博主也是我挺久之前就关注了的，不像是骗人的主，我就点进去链接看了下，发现 V2EX 上也有相关讨论贴（都被移动到「无要点」节点了，登录才能看）：</p><ul><li><a href="https://www.v2ex.com/t/645078" target="_blank" rel="noopener">20190204 以前有 16 位以上 GitHub 粉丝的，可领取目前价值 $2000 的空投</a></li><li><a href="https://www.v2ex.com/t/645480" target="_blank" rel="noopener">开源开发者免费来薅 1000 刀资本主义羊毛</a></li></ul><p>看了帖子里的评论，又去搜了下相关信息，感觉还是比较靠谱的。</p><hr><p>按照 Namebase 官网上 <a href="https://www.namebase.io/airdrop" target="_blank" rel="noopener">Handshake Airdrop</a> 的说明：</p><blockquote><p>The Handshake Organization raised money from top Silicon Valley investors including A16Z and Sequoia. They donated $10.2mm to GNU, Mozilla, and other internet foundations.</p><p>Now they’re giving away ~4662 Handshake coins to qualifying developers on GitHub.</p></blockquote><p>差不多就是「我们拉到了很多投资，很有钱，现在要大撒币」。🤔</p><p>那这 Handshake 又是何方神圣，哪拉来的那么多钱？根据<a href="https://handshake.org/" target="_blank" rel="noopener">官网</a>：</p><blockquote><p><strong>Decentralized naming and certificate authority</strong></p><p>Handshake is a decentralized, permissionless naming protocol where every peer is validating and in charge of managing the root DNS naming zone with the goal of creating an alternative to existing Certificate Authorities and naming systems. (…)</p><p>Handshake uses a coin system for name registration. The Handshake coin (HNS) is the mechanism by which participants transfer, register, and update internet names. (…) Therefore, Handshake allocates the majority of its initial coins towards the FOSS community with absolutely no obligation attached, as it is this community most relevant with decentralized software and tools. (…)</p><p>Handshake’s incentive design assumptions relies upon Metcalfe’s Law (Beckstrom’s Law, etc.). While Bitcoin’s value is derived from it being a costly store of value, Handshake’s value is derived from its network of users. Metcalfe’s Law asserts that an increase in userbase increases the value of the network (sub)exponentially. This means that allocation of value to potential developers and users of this system be a benefit to everyone, with network effect derived benefiting all users.</p></blockquote><p>嗯，看起来挺靠谱的。利用区块链技术构建的去中心化的域名注册、认证、交易和解析系统，使用 HNS 代币进行域名交易等操作，也解释了为啥要把这么多代币直接白送给 FOSS 开发者。</p><p>毕竟这还是我第一次接触币圈（之前只是有所耳闻，知道点原理而已），所以又去做了不少功课。</p><p>根据 Wikipedia，数字货币领域的 <a href="https://zh.wikipedia.org/wiki/%E7%A9%BA%E6%8A%95_(%E5%8C%BA%E5%9D%97%E9%93%BE)" target="_blank" rel="noopener">空投 (Airdrop)</a> 是这样定义的：</p><blockquote><p>区块链领域的空投是一种将数字货币通过区块链技术大规模分发到一些已有的数字货币，比如以太币、比特币、EOS.IO 钱包地址上的技术。空投在区块链领域亦视作一种提升一个产品概念影响力的市场策略。在 Facebook 等社交媒体拒绝刊登数字货币广告后，空投在区块链的营销中已变得越发重要。</p></blockquote><p>推广用户群体、扩散知名度、吸引投资以及参与者……从这些方面考虑，空投确实不失为一种方法。毕竟要不是这次听说有羊毛薅，我压根就不会知道还有 Handshake 这玩意儿。如果将其视作赚吆喝的营销手段，那至少在我身上效果确实是达到了。</p><p>然后我又寻思，HNS 发了这么多出去，这币怎么还能值钱呢？听说最开始这 4246 HNS 是值 $2000 的，到 2/18 的时候差不多 $1400，2/19 下午 $700，我 2/20 中午卖的时候就只有 $500 左右了（汇率 0.000013 BTC）。</p><p>可以看到虽然贬值很快，但作为白薅的羊毛还是很值钱的（也许是因为有初始资金撑着，或者除了羊毛党卖出外还有不少人在投资？或许操盘的都预料到了）。至于为什么能值钱，经济学方面就不是我的专门领域了。什么价值共识啊、供求关系之类的我也就看了点皮毛懂个大概，不贻笑大方了，等多看点书再来吧。</p><p>自认为韭菜我也没兴趣持币观望，感觉在可见的未来内还会跌，趁早换 BTC 跑路吧。</p><hr><p>下面是我自己换币变现的记录。</p><p><strong>官方教程在这里</strong>：<a href="https://www.namebase.io/airdrop" target="_blank" rel="noopener">https://www.namebase.io/airdrop</a></p><p>我的 GitHub 账号上传过 SSH 公钥，在 2019/02/04 之前也有百来个 follower，所以应该是符合条件。当然前提是你得保留着当时的私钥，要是丢了就 GG 了。另外，可能不是所有符合条件的用户都被快照到了，看论坛上的帖子说还得看脸。除了 GitHub，符合 PGP WoT Strong Set 等条件的用户也可以领币，具体参见官网。</p><p>下载 <code>hs-airdrop</code> 软件源码：</p><pre><code class="bash">git clone https://github.com/handshake-org/hs-airdrop.git</code></pre><p>安装依赖（软件是用 Node.js 写的）：</p><pre><code class="bash">cd hs-airdrop &amp;&amp; npm install</code></pre><p>运行：</p><pre><code class="bash">./bin/hs-airdrop &lt;path to key&gt; &lt;address&gt; &lt;fee&gt;</code></pre><p>其中 <code>&lt;path to key&gt;</code> 是你 SSH 私钥的路径（也可以是 PGP 私钥，具体看文档），<code>&lt;address&gt;</code> 是 HNS 钱包地址（可以在上面那个官方教程页面上直接生成），<code>&lt;fee&gt;</code> 是给矿工的费用（我设置了 <code>0.5</code>，官方示例的 <code>0.01</code> 可能导致状态一直卡在 Almost mined，推荐设置高一点）。</p><p>大部分人在这里都会警觉，要我 SSH 私钥干嘛？这么重要的东西，能保证安全吗？</p><p>当然没有绝对的安全，小心点不是坏事。从密码学角度，你之所以能领到这些 HNS 币，是因为 Handshake 团队抓取了 GitHub 上 Top 250,000 的开发者的公钥信息，并且把这些公钥经过某种算法处理放到了 HNS 的区块链上。那你要如何证明这个公钥是你的，如何证明你可以拿这些 HNS 币呢？除了提供私钥别无他法。</p><blockquote><p>说到 GitHub 用户的公钥……</p><p>有兴趣的话可以试试 <a href="https://twitter.com/FiloSottile/status/1229093553269362689" target="_blank" rel="noopener"><code>ssh whoami.filippo.io</code></a> 😏</p></blockquote><p>你用你的私钥生成一个密码学上的证明，放到 HNS 区块链上，这样网络就会承认你拥有这些 HNS 币了。<code>hs-airdrop</code> 就是这么一个工具，用你的私钥进行签名，并生成 merkle proof。<strong>关于隐私和安全性</strong>，README 里也都写得挺清楚，我就不赘述了。源码我看过，也是我自己 build 的，我选择相信它。如果实在不放心，可以直接薅完换一个 SSH 密钥（事实上我这个密钥就是当时旧机器上的 :P）。</p><p>运行的过程中会从 GitHub 下载 50MB 左右的 merkle tree 和 nonce，如果网络不好的话可能会失败。可以直接挂代理运行，或者手动把 <a href="https://github.com/handshake-org/hs-tree-data" target="_blank" rel="noopener">handshake-org/hs-tree-data</a> 的内容下载到 <code>~/.hs-tree-data</code> 目录里即可。</p><p>如果一切顺利，把最后生成的一串 base64 字符串粘贴到网页上提交就 OK 了。</p><p><img src="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2020/namebase-handshake-airdrop/creating-proof.png" srcset="/images/loading.jpg" data-srcset="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2020/namebase-handshake-airdrop/creating-proof.png" alt="creating-proof"></p><p>空投到账需要一段时间的确认（100 个区块，一个块 10 分钟，大概要 16 小时），Namebase（HNS 官方交易所）网页上会显示状态（Almost mined/waiting for more confirmations），到账后会有邮件通知。</p><p><img src="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2020/namebase-handshake-airdrop/handshake-award-claimed.png" srcset="/images/loading.jpg" data-srcset="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2020/namebase-handshake-airdrop/handshake-award-claimed.png" alt="handshake-award-claimed"></p><p>邮件里还会鼓励你拿这些币去捣鼓 Handshake 域名，如果你相信他们的鬼话和项目的前景，倒是可以试一试，不过我这种羊毛党就是薅完就跑的选手（x）。</p><p><del>等待的这段时间里你可以坐和放宽，像我一样看着汇率不停往下跌。</del></p><hr><p>空投到账后，接下来就是把 HNS 换成 BTC 了。</p><p>和其他交易所一样，在 Namebase 交易同样需要通过 KYC 身份认证，需要上传身份证/护照之类的。KYC 用的是 Netverify，查了一下好像是挺老牌的，这方面的安全性就请各位自行斟酌了。看 V2EX 上说身份证用网图也能过，不过我没试过。</p><p>卖 HNS 最好去 <a href="https://www.namebase.io/pro" target="_blank" rel="noopener">Namebase Pro</a> 交易，比起直接一键 Sell HNS，有K线图、成交量、阶梯挂单等高级功能。</p><p>最后卖得的 BTC，可以从交易所提到自己的比特币地址（点 Withdraw）：</p><p><img src="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2020/namebase-handshake-airdrop/withdraw-btc.png" srcset="/images/loading.jpg" data-srcset="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2020/namebase-handshake-airdrop/withdraw-btc.png" alt="withdraw-btc"></p><p>从截图可以看到，比起我清仓时的汇率，我现在写文时的汇率又有所上涨（0.000013 BTC）。大佬可以尝试再观望一下回升甚至抄底上车，咱就不奉陪了哈哈。</p><p>如果自己没有比特币地址，可以去比特币交易所注册个账号（火币、币安、OKEx 这些都是比较著名的数字货币交易所，哪个好我也不清楚，就不推荐了），从 Namebase 提到这些交易所的充币地址上，确认后 BTC 就会到你交易所的户头上了。</p><p>不过注意地址别填错，不然币就没咯。</p><hr><p>最后的步骤是提现，变成手里实实在在的钱。</p><p>交易所一般都有渠道进行法币兑换，这里就不多说了。我实际测试提现了一点到支付宝，很快就到账了没问题，白嫖大成功，爽死了。</p><p>不过我其实还是挺看好比特币以后的行情的，所以打算把大部分币都留着。</p><p>网上经常说，投资要用丢了不心疼的钱去投，我这点钱正好又是天上掉馅饼，那就当作年轻人的第一笔投资吧（笑）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;没想到我人生中第一次 Cryptocurrency 实操经验，竟然是白嫖出来的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="日常" scheme="https://printempw.github.io/categories/diary/"/>
    
    
      <category term="数字货币" scheme="https://printempw.github.io/tag/%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>备份聊天记录至 Sandboxie 内运行的微信</title>
    <link href="https://printempw.github.io/wechat-backup-in-sandboxie/"/>
    <id>https://printempw.github.io/wechat-backup-in-sandboxie/</id>
    <published>2020-02-12T19:03:00.000Z</published>
    <updated>2020-02-12T19:03:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>微信，骂归骂，用还是得用的，没办法。</p><p>聊天软件嘛，主要还是得看聊的对象 TA 们用什么。毕竟在国内生活，如果大部分人都是微信、QQ，那你一个人坚持 Telegram、Slack 也不过是一厢情愿而已。</p><p>今天在用微信 PC 版的「备份聊天记录至电脑」功能时，出现了奇怪的问题，明明已经连接同一个 WiFi 网络了，却老是提示「请保持手机与电脑才同一网络后重试」。最后发现其实是 Sandboxie 导致的，姑且在此记录一下。</p><a id="more"></a><hr><p>我有点数字洁癖，不愿意在个人电脑上直接跑各种国产毒瘤软件（包括不限于微信、QQ、百度网盘客户端、迅雷、阿里旺旺）。但也不至于到开虚拟机的程度，所以我选择用 Sandboxie 来把它们隔离起来。</p><blockquote><p>Sandboxie 是一款非常经典老牌的沙盒程序/沙盘工具，功能类似以前的“影子系统”，它可以在 Windows 上创造出一个虚拟的程序运行环境，并牢牢地限制住软件只能在其“沙盒环境”范围内运行，与真实系统完全隔离开来。所有运行在 Sandboxie 的虚拟“沙盘环境”里的应用程序都无法对真实系统产生任何影响，也无法修改你的硬盘数据。(<a href="https://www.iplaysoft.com/sandboxie.html" target="_blank" rel="noopener">Ref</a>)</p></blockquote><p>另外 Sandboxie 之前已经宣布免费了（就在我刚续完一年授权之后😂），有类似需求的朋友都可以试试。使用体验真的很棒，再也不用担心毒瘤软件在电脑里到处拉屎、改注册表了。</p><p>微信我也是放在 Sandboxie 中运行的，其他功能都正常，然而备份手机聊天记录至电脑时就出问题了。</p><p>众所周知，微信对聊天记录的处理非常奇葩。不像 QQ 那样提供聊天记录漫游，<a href="http://news.sina.com.cn/o/2018-01-02/doc-ifyqchnr8366660.shtml" target="_blank" rel="noopener">美其名曰</a>「微信不留存任何用户的聊天记录，聊天内容只存储在用户的手机、电脑等终端设备上」。<del>当婊子还立牌坊</del> 至于你信不信，我反正信了。</p><p>然而我在尝试使用官方的备份聊天记录至电脑功能时，却提示我不在同一网络下：</p><p><img src="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2020/wechat-backup-in-sandboxie/wechat-backup-failed.png" srcset="/images/loading.jpg" data-srcset="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2020/wechat-backup-in-sandboxie/wechat-backup-failed.png" alt="wechat-backup-failed"></p><p>明明我手机电脑已经连到同一个 WiFi 了啊？为什么还说电脑网络是 LAN 呢？</p><p>排查了好久，最后发现是 Windows 防火墙的问题。</p><p>微信这个聊天记录备份涉及局域网内通信，一般来说第一次运行时就会弹出 Windows 网络防火墙的提示，问你允不允许。然而在 Sandboxie 内这个提示似乎是被吞了，直接失败，导致了上面的问题。</p><p>解决方法就是 <strong>暂时关闭 Windows 防火墙</strong>，关了就可以正常备份了。</p><p><img src="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2020/wechat-backup-in-sandboxie/disable-windows-firewall.png" srcset="/images/loading.jpg" data-srcset="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2020/wechat-backup-in-sandboxie/disable-windows-firewall.png" alt="disable-windows-firewall"></p><p>如果不放心，也可以临时开一个热点来备份。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微信，骂归骂，用还是得用的，没办法。&lt;/p&gt;
&lt;p&gt;聊天软件嘛，主要还是得看聊的对象 TA 们用什么。毕竟在国内生活，如果大部分人都是微信、QQ，那你一个人坚持 Telegram、Slack 也不过是一厢情愿而已。&lt;/p&gt;
&lt;p&gt;今天在用微信 PC 版的「备份聊天记录至电脑」功能时，出现了奇怪的问题，明明已经连接同一个 WiFi 网络了，却老是提示「请保持手机与电脑才同一网络后重试」。最后发现其实是 Sandboxie 导致的，姑且在此记录一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://printempw.github.io/categories/tech/"/>
    
    
      <category term="软件" scheme="https://printempw.github.io/tag/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="Sandboxie" scheme="https://printempw.github.io/tag/Sandboxie/"/>
    
  </entry>
  
  <entry>
    <title>AUR 软件包的依赖版本太新怎么办</title>
    <link href="https://printempw.github.io/aur-package-depends-on-future-version/"/>
    <id>https://printempw.github.io/aur-package-depends-on-future-version/</id>
    <published>2020-02-07T19:50:00.000Z</published>
    <updated>2020-02-07T19:50:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天升级软件包时出了点问题，提示是这样的：</p><pre><code class="plain">$ yay -S qv2ray==&gt; Error: Could not find all required packages:    grpc&gt;=1.27.0 (Wanted by: qv2ray)    grpc-cli&gt;=1.27.0 (Wanted by: qv2ray)</code></pre><p><a href="https://github.com/Qv2ray/Qv2ray/" target="_blank" rel="noopener">Qv2ray</a> 新版本添加了不少功能，我也看过 CHANGELOG，新加了 gRPC 的依赖没毛病。但为什么说找不到软件包呢？</p><a id="more"></a><p>先看看 AUR 上的 Qv2ray <a href="https://aur.archlinux.org/packages/qv2ray/" target="_blank" rel="noopener">软件包信息</a>：</p><pre><code class="bash">yay -Si qv2ray</code></pre><pre><code>:: Querying AUR...Repository      : aurName            : qv2rayKeywords        : gui  qt  qv2ray  v2rayVersion         : 2.0.1-1Description     : Cross-platform V2ray Client written in Qt (Stable Release)URL             : https://github.com/Qv2ray/Qv2rayAUR URL         : https://aur.tuna.tsinghua.edu.cn/packages/qv2rayGroups          : NoneLicenses        : GPL3Provides        : qv2rayDepends On      : hicolor-icon-theme  qt5-charts&gt;5.11.0  grpc&gt;=1.27.0Make Deps       : git  make  qt5-tools  which  gcc  qt5-declarative  grpc-cli&gt;=1.27.0Check Deps      : NoneOptional Deps   : v2ray  v2ray-domain-list-community  v2ray-geoipConflicts With  : NoneMaintainer      : DuckSoftVotes           : 5Popularity      : 1.607244First Submitted : Wed 28 Aug 2019 09:38:57 PM CSTLast Modified   : Thu 06 Feb 2020 09:49:45 PM CSTOut-of-date     : No</code></pre><p>嗯，新添加了 <code>grpc&gt;=1.27.0</code> 和 <code>grpc-cli&gt;=1.27.0</code> 这两个依赖，就是上面报错的东西。</p><p>再看看这俩软件包的信息：</p><pre><code class="bash">yay -Si grpc</code></pre><pre><code>Repository      : communityName            : grpcVersion         : 1.26.0-4Description     : High performance, open source, general RPC framework that puts mobile and HTTP/2 first.Architecture    : x86_64URL             : https://grpc.ioLicenses        : BSDGroups          : NoneProvides        : NoneDepends On      : c-ares  protobuf  opensslOptional Deps   : NoneConflicts With  : NoneReplaces        : NoneDownload Size   : 1896.84 KiBInstalled Size  : 11315.30 KiBPackager        : Massimiliano Torromeo &lt;massimiliano.torromeo@gmail.com&gt;Build Date      : Thu 02 Jan 2020 04:12:49 PM CSTValidated By    : MD5 Sum  SHA-256 Sum  Signature</code></pre><p>好嘛！软件源里最新版本才 <code>1.26.0</code>，<code>grpc&gt;=1.27.0</code> 这个依赖能满足得了才有鬼了。</p><p>为什么会这样呢？</p><ul><li><del>AUR 软件包的维护者是未来人</del></li><li>你的软件源太旧了</li></ul><p>如果你正在使用 Manjaro Linux，那么遇到这种情况并不奇怪。Manjaro 是基于 Arch Linux 的，虽然包管理都是那套，但为了追求稳定，Manjaro 不会像 Arch 那样尽可能快地追软件的版本号，一般都是过一段时间后才会把软件源里的包更新到最新版本（也相对降低了滚挂的风险）。</p><p>比如 Arch 软件源里的 <code>community/grpc</code> 现在的版本是 <code>1.27.0</code>（2020-02-05 更新），而 Manjaro 软件源里依然停留在 <code>1.26.0</code>，就造成了开头的那个报错。这个尴尬的情况我之前也碰到过一次，是安装什么软件我忘了，反正当时是 Python 3.8 刚发布就指定了依赖 <code>python&gt;=3.8</code>，对于紧跟新版本的 Arch 用户来说自然不算啥，但官方软件源里 Python 还停留在 3.7 的 Manjaro 用户就吃瘪了。</p><p>解决方法也有两种。如果这个 AUR 包是<strong>确确实实地需要新版本依赖</strong>，用旧版本的不能跑，那就只能自己想办法安装新版本的依赖了。但是这样比较麻烦，官方软件源里没有又要去别处弄，所以如果现有版本的依赖也能跑的话，可以修改一下 AUR 软件包，让它不要要求那么高，拿旧版本的凑合凑合得了。</p><p>获取 <code>PKGBUILD</code>（这里以 <code>yay</code> 为例，用其他方法获取也一样）：</p><pre><code class="bash">yay -G qv2ray</code></pre><p>修改 <code>PKGBUILD</code> 中的依赖版本：</p><pre><code class="diff">diff --git a/PKGBUILD b/PKGBUILDindex deef5ab..2628076 100644--- a/PKGBUILD+++ b/PKGBUILD@@ -9,9 +9,9 @@ pkgdesc=&quot;Cross-platform V2ray Client written in Qt (Stable Release)&quot; arch=(&#39;x86_64&#39;) url=&#39;https://github.com/Qv2ray/Qv2ray&#39; license=(&#39;GPL3&#39;)-depends=(&#39;hicolor-icon-theme&#39; &#39;qt5-charts&gt;5.11.0&#39; &#39;grpc&gt;=1.27.0&#39;)+depends=(&#39;hicolor-icon-theme&#39; &#39;qt5-charts&gt;5.11.0&#39; &#39;grpc&gt;=1.26.0&#39;) optdepends=(&#39;v2ray&#39; &#39;v2ray-domain-list-community&#39; &#39;v2ray-geoip&#39;)-makedepends=(&#39;git&#39; &#39;make&#39; &#39;qt5-tools&#39; &#39;which&#39; &#39;gcc&#39; &#39;qt5-declarative&#39; &#39;grpc-cli&gt;=1.27.0&#39;)+makedepends=(&#39;git&#39; &#39;make&#39; &#39;qt5-tools&#39; &#39;which&#39; &#39;gcc&#39; &#39;qt5-declarative&#39; &#39;grpc-cli&gt;=1.26.0&#39;) provides=(&#39;qv2ray&#39;) source=(&quot;Qv2ray-${pkgver}::git+${url}#tag=v${pkgver}&quot;) sha512sums=(&#39;SKIP&#39;)</code></pre><p>安装依赖、构建并安装软件包：</p><pre><code class="bash">makepkg -si</code></pre><p>软件包安装完成：</p><pre><code class="bash">pacman -Qi qv2ray</code></pre><pre><code>Name            : qv2rayVersion         : 2.0.1-1Description     : Cross-platform V2ray Client written in Qt (Stable Release)Architecture    : x86_64URL             : https://github.com/Qv2ray/Qv2rayLicenses        : GPL3Groups          : NoneProvides        : qv2rayDepends On      : hicolor-icon-theme  qt5-charts&gt;5.11.0  grpc&gt;=1.26.0Optional Deps   : v2ray [installed]                  v2ray-domain-list-community [installed]                  v2ray-geoip [installed]Required By     : NoneOptional For    : NoneConflicts With  : NoneReplaces        : NoneInstalled Size  : 3.35 MiBPackager        : Unknown PackagerBuild Date      : Sat 08 Feb 2020 02:51:10 AM CSTInstall Date    : Sat 08 Feb 2020 02:52:02 AM CSTInstall Reason  : Explicitly installedInstall Script  : NoValidated By    : None</code></pre><p>等下一次 Qv2ray 更新的时候，Manjaro 的软件源估计也差不多更新了，到时候再用新版本构建就 OK 了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天升级软件包时出了点问题，提示是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;plain&quot;&gt;$ yay -S qv2ray

==&amp;gt; Error: Could not find all required packages:
    grpc&amp;gt;=1.27.0 (Wanted by: qv2ray)
    grpc-cli&amp;gt;=1.27.0 (Wanted by: qv2ray)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Qv2ray/Qv2ray/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Qv2ray&lt;/a&gt; 新版本添加了不少功能，我也看过 CHANGELOG，新加了 gRPC 的依赖没毛病。但为什么说找不到软件包呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://printempw.github.io/categories/tech/"/>
    
    
      <category term="Linux" scheme="https://printempw.github.io/tag/Linux/"/>
    
      <category term="Arch" scheme="https://printempw.github.io/tag/Arch/"/>
    
  </entry>
  
  <entry>
    <title>2020，祝大家各自安好</title>
    <link href="https://printempw.github.io/happy-new-year-2020/"/>
    <id>https://printempw.github.io/happy-new-year-2020/</id>
    <published>2020-01-24T19:13:00.000Z</published>
    <updated>2020-01-24T19:13:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>一年又一年，掐指一算，本博客差不多要迎来第五个年头了。当年刚买来虚拟主机捣鼓 WordPress 建站、一腔热血的小菜鸟，已经成长为了现在的摸鱼怪，可悲可叹。</p><p>在农历新年之后才发文也不是有什么讲究，单纯就是因为懒所以一月份都没写而已。摸鱼谁不爱呢？今天这篇博文也不是年终总结，就随便写写。2019 我过得浑浑噩噩，也没什么特别值得怀念的，不提也罢。</p><p>下面的内容可能有点愤青，各位酌情阅读。</p><a id="more"></a><br><p>我不当愤青已经很久了，现在也没有当的打算。多累啊。</p><p>愤怒又有什么用呢？在现在的社会环境下，愤怒似乎只会成为「理性客观中立」者的笑柄，或者寻衅滋事、违反相关法律法规的把柄。不同的立场，不和谐的声音，永远都是众矢之的。</p><p>但麻木同样没用。如果说心存异议还能有一线希望，那麻木地接受现状就真的只是令人宰割了。同样是流水线上的猪，你鸡贼点往后挪一挪，和那些原地不动甚至主动体谅猪户难处往前挤、高声唱颂养猪场老板最亲的猪，可能下场就不太一样。</p><br><p>我非常不明白的一点是，为什么 2020 年了还是有那么多的人分不清国家、个人、政府和政党。有些满口「阿中哥哥」的网民，批评一句政府好像要了他们的命一样，非要给你扣上恨国的帽子。</p><p>拜托，要是真的想让这个国家完蛋，那还批评啥子呀？有问题不提，大家都装作没看见，也不许别人说，一个劲儿地赞美，就等房间里的大象越来越大，最后一脚踩死所有人，岂不快哉？</p><p>异议是爱国的最高形式，虽然这好像不是杰弗逊说的。对问题视而不见或者矮小化，试图帮助政府一起解决提出问题的人的那些所谓爱国者，或许才最应该冠以「别有用心带节奏的境外势力」之称号。「嫌中国不好就滚出中国，太平洋没加盖」这种经典句式竟然到现在还有人用，实在是令我感受到教育的悲哀。</p><br><p>所以每次我看到这些无脑挺政府的小粉红时都不禁想，他妈的等这些恶性社会事件轮到你头上时，我倒看看你还能不能这么精神赵家人。（对，就是所谓的「社会主义铁拳」。真被砸了可怜他们是一回事，看着还是挺爽的）</p><p>结果没想到大规模瘟疫真的来了，还来得这么快，传染性与波及范围之广也让人们没法事不关己高高挂起。而且作为发源地的湖北省武汉市还真就上演了一出教科书一般的无能政府惹众怒 —— 我在疫情消息刚出来的时候就关注了，还以为有过 17 年前非典经验了应该不会处理得太差，不曾想现实真的比小说还离奇。</p><p>我实在是有些哭笑不得。包括之前开奔驰进故宫、中福在线连环夺宝等热点事件唤起的大众对特权阶层的质疑，政府公信力的下降，所有这些都凑在 2020 开年了，不得不说感觉挺巧的。</p><p>举头三尺有神明，人在做天在看，或许果真如此？哈哈。</p><br><p>我有点希望这次灾难更猛烈些，好让每个人都醒悟，让社会推动着去解决一些平时绝无可能自行治愈的顽疾。但当我看到俨然人间炼狱的疫区、情绪崩溃的一线医护工作者、求诊无门的病患时，我又没法这么想了。他们也是人，凭什么作出这么大的牺牲，凭什么成为不计一切代价中的代价？如果灾难中心的是我，还说得出这种风凉话吗？</p><p>矛盾的心态让我这几天夜不能寐，之前买来的褪黑素和零点前睡觉的计划也抛之脑后了。我不是心系天下的圣人，但良心还在。</p><p>我只能眼睁睁地看着，既不祈祷，也不诅咒。仿佛在看一场不知道结局的电影。</p><br><p>再说疫情本身。新型冠状病毒，致病机理与 SARS 相同，明确人传人，目前没有特效药。由于政府无能不作为导致的行动迟缓（甚至还在开团拜会、春节联欢晚会、万家宴）、数据瞒报、前期疫情大幅扩散。封城后物资供应跟不上、交通无法保障、医疗资源不足、医护人员超负荷工作，口罩等物资甚至还要医院公开向社会求助……没有一个是不令人担心的。</p><p>看着微博上人们痛骂武汉政府要求下台、不信谣不传谣、相信国家相信中央、怒喷逃离武汉的人、点赞河南省的处理方案、跪求自己的省份城市启动一级响应、冷嘲热讽、祈福致敬、和新浪审核作对疫区情况屡删屡发，一片水深火热。而同时电视机里的春节联欢晚会却又是歌舞升平、一片祥和，仿佛是两个世界，我又觉得很无力。</p><p>听着主持人讲些激动人心的屁话，内心毫无波澜，只是觉得这社会的讽刺度与魔幻度在今晚似乎达到了最高潮。会因为这种低级鸡血而热血沸腾、相信一切都能圆满解决的人，大概才是真的韭精中毒吧。</p><br><p>当然我也大可不必这么悲观。幸存者偏差的存在总是会另国内媒体平台上符合主旋律的东西多一些，在加上沉默的大多数，所看到的这些也许并不能反映真实情况。我愿意相信，明眼人还是要多一些的。</p><blockquote><p>We learn from history that we do not learn from history.</p></blockquote><p>既然如此，只要继续重蹈覆辙，或许总会像以前那样发生点什么变化。</p><p>当然如果实在不行那也没办法，大家自求多福。</p><p>我作为个人的力量非常有限。我没有站出来发声的勇气，没有针砭时弊的高度，没有叫醒真睡或是装睡的大众的自大，我甚至懒得与人争论。我能做的，充其量就是躲在网络的匿名身份后敲敲键盘罢了。见证现在发生在眼前的一切，把所有的热量都藏在心底。韭菜虽然还是韭菜，但也不能做最绿的那根自己往镰刀下送对吧。</p><br><p>独立思考，不忘质疑。</p><p>态度也是一种力量。</p><br><p>妈的，为了写这点破东西，过年群里红包都没领着，可恶。</p><p>我已经写了四年博客，再撑个几年应该也没问题。反正爱写就写，不想写就摸着，不给自己造成负担，也挺快活。我这人挺俗的，上网冲浪，总是想留下点什么痕迹。也不管有没人看，主要就是图个自我满足。</p><br><p>致我深爱着的这个操蛋的世界。</p><p>2020，祝大家各自安好。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一年又一年，掐指一算，本博客差不多要迎来第五个年头了。当年刚买来虚拟主机捣鼓 WordPress 建站、一腔热血的小菜鸟，已经成长为了现在的摸鱼怪，可悲可叹。&lt;/p&gt;
&lt;p&gt;在农历新年之后才发文也不是有什么讲究，单纯就是因为懒所以一月份都没写而已。摸鱼谁不爱呢？今天这篇博文也不是年终总结，就随便写写。2019 我过得浑浑噩噩，也没什么特别值得怀念的，不提也罢。&lt;/p&gt;
&lt;p&gt;下面的内容可能有点愤青，各位酌情阅读。&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="https://printempw.github.io/categories/essay/"/>
    
    
  </entry>
  
  <entry>
    <title>教你写一个 Zsh 主题</title>
    <link href="https://printempw.github.io/zsh-prompt-theme-customization/"/>
    <id>https://printempw.github.io/zsh-prompt-theme-customization/</id>
    <published>2020-01-16T13:30:00.000Z</published>
    <updated>2020-01-16T15:10:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>昨天在配置新 VPS 时突然想到，推荐 Zsh 主题、讲如何设置主题的中文教程有很多，但似乎鲜有教人怎么去自己编写一个 Zsh 主题的。搜索了一下确实没多少，Bash 自定义提示符的教程倒是挺多。既然如此，那就我来写一个吧。</p><a id="more"></a><h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h2><p>开始动手之前，先来了解一下类 Unix 系统中命令行的一些基础知识。如果你之前有过自定义 Bash 等 Shell 的提示符的经验，可以直接跳过这一段，毕竟除了一些 Zsh 特有的东西之外都是一样的。</p><blockquote><p>再次推荐一下我的这篇文章：<a href="https://printempw.github.io/the-difference-between-cli-terminal-shell-tty/">命令行界面 (CLI)、终端 (Terminal)、Shell、TTY，傻傻分不清楚？</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2020/zsh-prompt-theme-customization/shell-prompt.png" srcset="/images/loading.jpg" data-srcset="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2020/zsh-prompt-theme-customization/shell-prompt.png" alt="shell-prompt"></p><p>在上面的截图中，<code>vagrant@homestead:~$</code> 这样的部分就叫做命令行提示符（Prompt）。顾名思义，提示符就是提示你输入 Shell 命令用的，每次运行完一个命令后都会再显示一次提示符，等待下一个命令。</p><p>不同发行版、不同 Shell 的默认提示符格式也不同。比如 CentOS 中默认的 Bash 提示符就是 <code>[printempw@localhost ~]$</code> 这样的。一般来说，提示符都会包含这些信息：当前用户、主机名、当前目录等。有些人的可能更高级，包括了当前 Git 状态、环境信息、时间、上一条命令的返回值等等。</p><p>那么这个提示符要怎么修改呢？答案就是 <code>$PS1</code> 环境变量。</p><blockquote><p>当然，并不是所有 Shell 都使用 <code>$PS1</code> 来控制提示符，比如 <a href="https://fishshell.com/docs/current/tutorial.html#tut_prompt" target="_blank" rel="noopener">fish</a>。</p></blockquote><p><code>PS1</code> 的意思是 <del>PlayStation</del> Prompt String One，控制最外层命令行的提示符，也是我们平时最常看到的。另外还有 <code>PS2</code>，当你输入一条多行命令时，左边的 <code>&gt;</code> 就是它。<code>PS3</code>、<code>PS4</code> 平时一般用不到，有兴趣的话可以看一下 <a href="https://www.thegeekstuff.com/2008/09/bash-shell-take-control-of-ps1-ps2-ps3-ps4-and-prompt_command/" target="_blank" rel="noopener">这篇文章</a>。</p><p>你可以在你的机器上尝试一下，看看这几个环境变量的值：</p><pre><code class="zsh">➜  ~ echo $PS1%(?:%{%}➜ :%{%}➜ ) %{$fg[cyan]%}%c%{$reset_color%} $(git_prompt_info)➜  ~ echo $PS2%_&gt;</code></pre><p>卧槽？这一大堆乱七八糟的是什么？</p><h2 id="2-必要元素之-Prompt-转义字符"><a href="#2-必要元素之-Prompt-转义字符" class="headerlink" title="2. 必要元素之 Prompt 转义字符"></a>2. 必要元素之 Prompt 转义字符</h2><p>在 <code>$PS1</code> 中，我们可以加入一些特殊的转义字符，Shell 会将它们解析成相应的值。不同 Shell 的转义字符也不同，比如 Bash 中显示主机名的转义字符是 <code>\h</code>，而 Zsh 上则是 <code>%m</code>。</p><p>Zsh 中可用的转义序列主要有：</p><table><thead><tr><th>转义字符</th><th>描述</th></tr></thead><tbody><tr><td><code>%n</code></td><td>当前用户名 <code>$USERNAME</code></td></tr><tr><td><code>%m</code></td><td>不带域名的本地主机名</td></tr><tr><td><code>%M</code></td><td>完整的主机名</td></tr><tr><td><code>%#</code></td><td>普通用户显示一个 <code>%</code> 字符，超级用户显示 <code>#</code></td></tr><tr><td><code>%?</code></td><td>上一条命令的执行结果</td></tr><tr><td><code>%d</code><br/><code>%/</code></td><td>当前工作目录</td></tr><tr><td><code>%~</code></td><td>当前工作目录，并使用 <code>~</code> 符号替换目录中的 <code>$HOME</code><br />（<code>%1~</code> 表示当前目录名，等效于 <code>%c</code>）</td></tr><tr><td><code>%D</code></td><td>当前日期，格式为 <em>yy-mm-dd</em></td></tr><tr><td><code>%T</code></td><td>当前时间，24 小时制</td></tr><tr><td><code>%{...%}</code></td><td>用于包裹 ANSI 转义序列</td></tr></tbody></table><p>这里只列举了一部分，完整列表请参考 <a href="http://zsh.sourceforge.net/Doc/Release/Prompt-Expansion.html" target="_blank" rel="noopener">Zsh 文档</a>。</p><p>实际操作一下（直接运行 <code>PS1=&#39;...&#39;</code> 即可，仅在当前会话生效）：</p><pre><code class="zsh">PS1=&#39;[%n@%m %1~]$ &#39;[vagrant@homestead ~]$</code></pre><pre><code class="zsh">PS1=&#39;%n at %m in %1~ λ &#39;vagrant at homestead in ~ λ</code></pre><pre><code class="zsh">PS1=&#39;我的天啊你看看都几点了 (%*)%# &#39;我的天啊你看看都几点了 (20:11:45)%</code></pre><h2 id="3-给点颜色看看！ANSI-转义序列"><a href="#3-给点颜色看看！ANSI-转义序列" class="headerlink" title="3. 给点颜色看看！ANSI 转义序列"></a>3. 给点颜色看看！ANSI 转义序列</h2><p>如果你看过我写的那篇关于终端的文章，应该知道 Shell 可以通过一些特殊的转义序列，控制终端上的字符颜色、光标位置等。<a href="https://zh.wikipedia.org/wiki/ANSI%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97" target="_blank" rel="noopener">ANSI 转义序列</a> 就是这些特殊序列的一种标准，基本上所有终端都支持（就连著名的小黑窗，Win32 控制台在 Windows 10 TH2 之后也支持 ANSI 转义序列了）。</p><p>以文本颜色为例，16 色 ANSI 转义序列大概长这样：</p><table><thead><tr><th align="left">序列</th><th align="left">文本颜色</th><th align="left">序列</th><th align="left">文本颜色</th></tr></thead><tbody><tr><td align="left"><code>\e[30m</code></td><td align="left">黑</td><td align="left"><code>\e[90m</code></td><td align="left">亮黑（灰）</td></tr><tr><td align="left"><code>\e[31m</code></td><td align="left">红</td><td align="left"><code>\e[91m</code></td><td align="left">亮红</td></tr><tr><td align="left"><code>\e[32m</code></td><td align="left">绿</td><td align="left"><code>\e[92m</code></td><td align="left">亮绿</td></tr><tr><td align="left"><code>\e[33m</code></td><td align="left">黄</td><td align="left"><code>\e[93m</code></td><td align="left">亮黄</td></tr><tr><td align="left"><code>\e[34m</code></td><td align="left">蓝</td><td align="left"><code>\e[94m</code></td><td align="left">亮蓝</td></tr><tr><td align="left"><code>\e[35m</code></td><td align="left">品红</td><td align="left"><code>\e[95m</code></td><td align="left">亮品红</td></tr><tr><td align="left"><code>\e[36m</code></td><td align="left">青</td><td align="left"><code>\e[96m</code></td><td align="left">亮青</td></tr><tr><td align="left"><code>\e[37m</code></td><td align="left">白</td><td align="left"><code>\e[97m</code></td><td align="left">亮白</td></tr></tbody></table><p>其中 <code>\e</code> 表示 <code>ESC</code> 的转义序列，也可以写作 <code>\033</code>、<code>\x1B</code>。</p><p>随着终端的发展，转义序列也有了更多的定义，支持到了 8 位（256 色）、16 位甚至 24 位色。详细的 ANSI 转义序列可以参考以下链接：</p><ul><li><a href="https://en.wikipedia.org/wiki/ANSI_escape_code" target="_blank" rel="noopener">ANSI escape code - Wikipedia</a></li><li><a href="https://misc.flogisoft.com/bash/tip_colors_and_formatting" target="_blank" rel="noopener">bash:tip_colors_and_formatting - FLOZz’ MISC</a></li></ul><blockquote><p>ANSI 标准规定了有哪些颜色，而这些颜色具体又显示成什么样，就得看终端的设置了。很多人乐此不疲地折腾「终端配色」，说的就是这个。</p></blockquote><p>测试一下：</p><pre><code class="zsh">print -P &#39;[%{\e[32m%}%n%{\e[0m%}@%{\e[31m%}%m %{\e[34m%}%1~%{\e[0m%}]$ &#39;[vagrant@homestead ~]$</code></pre><p>看花了？来张图，看得更清楚一点：</p><p><img src="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2020/zsh-prompt-theme-customization/zsh-ansi-escape-sequences.png" srcset="/images/loading.jpg" data-srcset="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2020/zsh-prompt-theme-customization/zsh-ansi-escape-sequences.png" alt="zsh-ansi-escape-sequences"></p><p>但是像这样手写一长串不直观的转义序列未免也太过低效，所以 Zsh 提供了几种方便地设置文本颜色的方法：</p><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>$fg[color]</code></td><td align="center">设置文本颜色，<code>color</code> 的取值可以是 <code>black</code> <code>red</code> <code>green</code> <code>yellow</code> <code>blue</code> <code>magenta</code> <code>cyan</code> <code>white</code> <code>default</code> 等</td></tr><tr><td align="center"><code>$fg_bold[color]</code></td><td align="center">设置文本为粗体同时设定文本颜色</td></tr><tr><td align="center"><code>$reset_color</code></td><td align="center">重置文本颜色为默认颜色</td></tr><tr><td align="center"><code>$bg[color]</code></td><td align="center">设置背景颜色</td></tr></tbody></table><p>完整的定义可以在 <a href="https://github.com/zsh-users/zsh/blob/master/Functions/Misc/colors" target="_blank" rel="noopener">Zsh 源码</a> 中查看。</p><blockquote><p>如果你没有使用 oh-my-zsh 之类的配置框架，你需要在 <code>.zshrc</code> 中手动加入 <code>autoload -U colors &amp;&amp; colors</code> 才能使用这些颜色代码。</p></blockquote><p>所以上面的示例也可以改写成这样（注意这里必须用双引号）：</p><pre><code class="zsh">print -P &quot;[%{$fg[green]%}%n%{$reset_color%}@%{$fg[red]%}%m %{$fg[blue]%}%1~%{$reset_color%}]$ &quot;[vagrant@homestead ~]$</code></pre><h2 id="4-Zsh-主题与-oh-my-zsh"><a href="#4-Zsh-主题与-oh-my-zsh" class="headerlink" title="4. Zsh 主题与 oh-my-zsh"></a>4. Zsh 主题与 oh-my-zsh</h2><p><a href="https://github.com/ohmyzsh/ohmyzsh" target="_blank" rel="noopener">oh-my-zsh</a> 是一个配置框架，自带了很多方便的函数、插件、主题，可以大幅简化复杂的 Zsh 配置。但是需要明确的是，并不是只有安装了 oh-my-zsh 之后才能自定义 Zsh 的命令提示符。</p><p>原生 Zsh 就内置了几种提示符主题，你可以这样来启用：</p><pre><code class="zsh">autoload -U promptinitpromptinitprompt -lprompt adam1</code></pre><p>不喜欢内置的，你可以直接把自定义的 <code>PROMPT=...</code> 写到 <code>.zshrc</code> 里去，大部分的 oh-my-zsh 主题也可以直接通过 <code>source</code> 使用。但是……都 2020 年了，真的还有直接用 Zsh 的人吗？请允许我膜拜一下。</p><p>所以咱也不用太咬文嚼字，「Zsh 主题」「oh-my-zsh 主题」都差不多，核心内容都是一样的。下文我介绍的是通过 oh-my-zsh 框架编写自定义 Zsh 主题的方法。</p><p>新建一个自定义主题：</p><pre><code class="zsh">touch $ZSH_CUSTOM/themes/my-theme.zsh-theme</code></pre><p>编辑我们想要的提示符格式：</p><pre><code class="zsh">PROMPT=&quot;[%{$fg[green]%}%n%{$reset_color%}@%{$fg[red]%}%m %{$fg[blue]%}%1~%{$reset_color%}]$ &quot;</code></pre><p>应用主题：</p><pre><code class="zsh">sed -i &#39;s/ZSH_THEME=&quot;.*&quot;/ZSH_THEME=&quot;my-theme&quot;/g&#39; ~/.zshrcsource ~/.zshrc</code></pre><h2 id="5-进阶功能"><a href="#5-进阶功能" class="headerlink" title="5. 进阶功能"></a>5. 进阶功能</h2><p>至此，你的主题已经初具雏形。</p><p>但是光提示用户名、当前目录这些信息可能还差点意思，网上那些大佬的主题可是五花八门啥都有，Git 分支、仓库状态、venv 信息、PHP 版本……看起来很高级。不过其实这些都没什么难的，理解了上面那些东西之后，去看一下源码 <del>借鉴一下</del> 就懂了。</p><p>下面以 oh-my-zsh 的默认主题 <a href="https://github.com/ohmyzsh/ohmyzsh/blob/master/themes/robbyrussell.zsh-theme" target="_blank" rel="noopener"><code>robbyrussell</code></a> 为例解剖一下：</p><pre><code class="zsh">PROMPT=&quot;%(?:%{$fg_bold[green]%}➜ :%{$fg_bold[red]%}➜ )&quot;PROMPT+=&#39; %{$fg[cyan]%}%c%{$reset_color%} $(git_prompt_info)&#39;ZSH_THEME_GIT_PROMPT_PREFIX=&quot;%{$fg_bold[blue]%}git:(%{$fg[red]%}&quot;ZSH_THEME_GIT_PROMPT_SUFFIX=&quot;%{$reset_color%} &quot;ZSH_THEME_GIT_PROMPT_DIRTY=&quot;%{$fg[blue]%}) %{$fg[yellow]%}✗&quot;ZSH_THEME_GIT_PROMPT_CLEAN=&quot;%{$fg[blue]%})&quot;</code></pre><p>先看最重要的前两行：</p><pre><code class="zsh">%(?:%{$fg_bold[green]%}➜ :%{$fg_bold[red]%}➜ )</code></pre><p>重温一下 Zsh 的 <a href="http://zsh.sourceforge.net/Doc/Release/Prompt-Expansion.html" target="_blank" rel="noopener">Prompt Expansion</a>，这是一个三元表达式。<code>?</code> 在上一条命令的返回值为 <code>0</code> 为 True，其他情况下为 False。在这里就是上一条命令成功的话输出绿色箭头，否则输出红色箭头。</p><pre><code class="zsh">%{$fg[cyan]%}%c%{$reset_color%} $(git_prompt_info)</code></pre><p><code>%c</code> 即当前目录名（虽然文档里说了 deprecated），等效于 <code>%1~</code>。整句的意思就是输出蓝色的当前目录名，然后重置回默认颜色，运行 <code>git_prompt_info</code>。</p><p><a href="https://github.com/ohmyzsh/ohmyzsh/blob/master/lib/git.zsh" target="_blank" rel="noopener"><code>git_prompt_info</code></a> 是 oh-my-zsh 内置函数，功能是解析当前目录的 Git 仓库状态（如果是的话），按照以下格式输出：</p><pre><code class="zsh">$ZSH_THEME_GIT_PROMPT_PREFIX$ref$(parse_git_dirty)$ZSH_THEME_GIT_PROMPT_SUFFIX# parse_git_dirty 的输出为$ZSH_THEME_GIT_PROMPT_DIRTY or $ZSH_THEME_GIT_PROMPT_CLEAN</code></pre><p><a href="https://github.com/ohmyzsh/ohmyzsh/blob/master/lib/theme-and-appearance.zsh#L48" target="_blank" rel="noopener">默认情况下</a>，这个函数的输出是这样的：</p><pre><code class="plain">git:(master*)</code></pre><p>不过这里主题覆盖了 <code>$ZSH_THEME_GIT_*</code> 系列变量，所以最后的输出是：</p><!-- ➜ blog git:(master) ✗ --><pre><code class="plain"><span style="color:#8AE234">➜&nbsp;</span><span style="color:#34E2E2">blog</span><span style="color:#D3D7CF">&nbsp;</span><span style="color:#729FCF">git:(</span><span style="color:#EF2929">source</span><span style="color:#729FCF">)&nbsp;</span><span style="color:#FCE94F">✗</span></code></pre><p>其他高级功能也差不多，都是利用 Shell 脚本实现的，这里就不多展开。</p><h2 id="6-我在用的主题"><a href="#6-我在用的主题" class="headerlink" title="6. 我在用的主题"></a>6. 我在用的主题</h2><p>我个人对那些华丽的主题也没啥兴趣，够用就行。</p><p>比如各大发行版默认的 Bash Prompt 就挺好（服务器上也用不到那些花里胡哨的），所以我把它们移植到了 Zsh 上。oh-my-zsh 的默认主题也不错，但是其中的 Unicode 箭头显示效果不尽如人意，我将其修改为了 ASCII 字符。</p><p>这些主题的源码可以在 <a href="https://gist.github.com/printempw/1ae3b8ae3091a6cfd65a22e1872af7ab" target="_blank" rel="noopener">Gist</a> 上查看。</p><p><img src="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2020/zsh-prompt-theme-customization/my-custom-zsh-themes.png" srcset="/images/loading.jpg" data-srcset="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2020/zsh-prompt-theme-customization/my-custom-zsh-themes.png" alt="my-custom-zsh-themes"></p><p>截图是 WSL + Windows Terminal，<a href="https://store.kde.org/p/1232062/" target="_blank" rel="noopener">Tango</a> 配色，<a href="https://github.com/microsoft/cascadia-code" target="_blank" rel="noopener">Cascadia Code</a> 字体。另一台装 Manjaro 的笔记本上用的是 GNOME Terminal + <a href="https://github.com/jeremyFreeAgent/oh-my-zsh-powerline-theme" target="_blank" rel="noopener">Powerline</a>，也挺好看的。</p><h2 id="7-参考链接"><a href="#7-参考链接" class="headerlink" title="7. 参考链接"></a>7. 参考链接</h2><ul><li><a href="http://zsh.sourceforge.net/Doc/Release/Prompt-Expansion.html" target="_blank" rel="noopener">zsh: 13 Prompt Expansion</a></li><li><a href="https://rzhao.io/blog/2015/08/26/zsh-prompt/" target="_blank" rel="noopener">Customize your zsh prompt - richard zhao</a></li><li><a href="https://en.wikipedia.org/wiki/ANSI_escape_code" target="_blank" rel="noopener">ANSI escape code - Wikipedia</a></li><li><a href="https://misc.flogisoft.com/bash/tip_colors_and_formatting" target="_blank" rel="noopener">bash:tip_colors_and_formatting - FLOZz’ MISC</a></li><li><a href="https://github.com/zsh-users/zsh/blob/master/Functions/Misc/colors" target="_blank" rel="noopener">zsh/colors at master · zsh-users/zsh</a></li><li><a href="https://wiki.archlinux.org/index.php/Bash/Prompt_customization" target="_blank" rel="noopener">Bash/Prompt customization - ArchWiki</a></li><li><a href="https://wiki.archlinux.org/index.php/Zsh" target="_blank" rel="noopener">Zsh - ArchWiki</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天在配置新 VPS 时突然想到，推荐 Zsh 主题、讲如何设置主题的中文教程有很多，但似乎鲜有教人怎么去自己编写一个 Zsh 主题的。搜索了一下确实没多少，Bash 自定义提示符的教程倒是挺多。既然如此，那就我来写一个吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://printempw.github.io/categories/tech/"/>
    
    
      <category term="Shell" scheme="https://printempw.github.io/tag/Shell/"/>
    
      <category term="Linux" scheme="https://printempw.github.io/tag/Linux/"/>
    
  </entry>
  
  <entry>
    <title>搭建备用梯子：V2Ray + WebSocket + TLS + CloudFlare</title>
    <link href="https://printempw.github.io/v2ray-ws-tls-cloudflare/"/>
    <id>https://printempw.github.io/v2ray-ws-tls-cloudflare/</id>
    <published>2020-01-12T12:20:00.000Z</published>
    <updated>2020-01-15T11:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>2020 年的第一篇博文竟然是讲虚拟砖混结构建筑物逾越技术的，感觉有点微妙。</p><p>年终总结啊，在写了在写了，明年就发。</p><a id="more"></a><p>因为嫌麻烦，我这几年基本用的都是现成的代理服务（俗称机场）。这样虽然不用担心自己机器 IP 被墙、速度方面基本有保障、节点也多，不过俗话说不要把鸡蛋放在一个篮子里，自建一个代理服务器备用还是很有必要的。</p><p>这几年翻墙技术似乎也发展了不少（是吗？），这次我选择的方法是 V2Ray + WebSocket + TLS + CloudFlare 中转：速度不重要，隐蔽性、抗干扰性第一。这么几层裹上去，除非真的掐网线搞大局域网，不然应该还是能撑个一段时间。</p><p>正文开始前先提个醒，本文不是小白教程，就是随手记录一下，所以我会假定你有一定的基础知识与操作经验。</p><h2 id="1-安装-V2Ray"><a href="#1-安装-V2Ray" class="headerlink" title="1. 安装 V2Ray"></a>1. 安装 V2Ray</h2><p>除非你是真的小白零经验，或者「能用就好」主义的忠实信奉者，不然我是不推荐你一上来就直接使用网上那些「一键脚本」的。</p><p>就算一键脚本再怎么优秀再怎么便利，至少也应该亲自手动操作一次，了解一下大致的流程。如果我想要做某件事，应该进行哪些操作，脚本会替我完成哪些操作，这些自动化操作是不是符合自己的预期（尤其是脚本是其他人写好的情况下），最起码这些东西得心里有数。</p><p>脚本写出来就是帮我们自动完成一些繁琐的操作的，其存在当然有意义，不然每台机器上都手动操作一遍过去，不得累死？用肯定是要用，我所不赞成的只是在不了解这个脚本的情况下瞎用。</p><p>线上服务器搭建 LNMP 环境时我也经常用 <a href="https://oneinstack.com/" target="_blank" rel="noopener">OneinStack</a> 这样的一键包，很方便。而且它的源码我也都看过，很清楚它能干嘛、会干嘛。也知道它自带的 <code>vhost.sh</code> 虚拟主机管理脚本虽然看起来挺友好，但其修改出来的东西经常惨不忍睹，所以服务器上 Nginx 的配置我从来不用它，都是自己管理的。</p><p>总的来说就是可以用傻瓜式脚本，但咱也不能真成傻瓜了，对吧。</p><hr><p>好了不说废话，来安装 V2Ray。</p><p>安装方法有很多，这里就直接用官方提供的脚本：</p><pre><code class="bash">bash &lt;(curl -L -s https://install.direct/go.sh)</code></pre><p>脚本会自动安装这些东西：</p><ul><li><code>/usr/bin/v2ray/v2ray</code> V2Ray 程序</li><li><code>/usr/bin/v2ray/v2ctl</code> V2Ray 工具</li><li><code>/etc/v2ray/config.json</code> 配置文件</li><li><code>/usr/bin/v2ray/geoip.dat</code> IP 数据文件</li><li><code>/usr/bin/v2ray/geosite.dat</code> 域名数据文件</li><li><code>/etc/systemd/system/v2ray.service</code> Systemd Service</li><li><code>/etc/init.d/v2ray</code> SysV 启动脚本</li></ul><h2 id="2-配置-V2Ray-服务端"><a href="#2-配置-V2Ray-服务端" class="headerlink" title="2. 配置 V2Ray 服务端"></a>2. 配置 V2Ray 服务端</h2><p>虽然严格来说 V2Ray 并不分客户端和服务端……反正就是那个意思啦。</p><p>编辑配置文件 <code>/etc/v2ray/config.json</code>：</p><pre><code class="javascript">{  &quot;inbounds&quot;: [{    &quot;port&quot;: 10086,    // 因为还要用 Nginx 反代，这里直接监听本地就行    &quot;listen&quot;: &quot;127.0.0.1&quot;,    &quot;protocol&quot;: &quot;vmess&quot;,    &quot;settings&quot;: {      &quot;clients&quot;: [        {          // 用户 UUID，自己随机弄一个          &quot;id&quot;: &quot;23ad6b10-8d1a-40f7-8ad0-e3e35cd38297&quot;,          &quot;level&quot;: 1,          &quot;alterId&quot;: 64        }      ]    },    &quot;streamSettings&quot;: {      // 指定底层传输方式为 WebSocket      &quot;network&quot;: &quot;ws&quot;,      &quot;wsSettings&quot;: {        // 在哪个路径上提供 WS 服务，可自定义        &quot;path&quot;: &quot;/whatever&quot;      }    }  }],  &quot;outbounds&quot;: [{    &quot;protocol&quot;: &quot;freedom&quot;,    &quot;settings&quot;: {}  },{    &quot;protocol&quot;: &quot;blackhole&quot;,    &quot;settings&quot;: {},    &quot;tag&quot;: &quot;blocked&quot;  }],  &quot;routing&quot;: {    &quot;rules&quot;: [      {        // 默认规则，禁止访问服务器内网        &quot;type&quot;: &quot;field&quot;,        &quot;ip&quot;: [&quot;geoip:private&quot;],        &quot;outboundTag&quot;: &quot;blocked&quot;      }    ]  }}</code></pre><p>上述配置是直接基于默认配置修改的，V2Ray 的配置很灵活，还有很多可以完善的地方。不过配置调优并不是本文的重点，所以这里按下不表，有兴趣可以自行阅读官方文档。</p><h2 id="3-运行-V2Ray"><a href="#3-运行-V2Ray" class="headerlink" title="3. 运行 V2Ray"></a>3. 运行 V2Ray</h2><p>配置完了，运行一下：</p><pre><code class="bash">systemctl start v2ray</code></pre><p>如果你的服务器不用 Systemd：</p><pre><code class="bash">service v2ray start# 要么/etc/init.d/v2ray start# 或者手动运行/usr/bin/v2ray/v2ray -config /etc/v2ray/config.json</code></pre><p>测试一下有没有跑起来：</p><pre><code class="bash">curl -i http://127.0.0.1:10086/whatever</code></pre><pre><code class="plain">HTTP/1.1 400 Bad RequestContent-Type: text/plain; charset=utf-8Sec-Websocket-Version: 13X-Content-Type-Options: nosniffDate: Sun, 12 Jan 2020 11:45:14 GMTContent-Length: 12Bad Request</code></pre><p>注意 curl 访问的端口和路径要和上面 V2Ray 中配置的一致，出现 400 Bad Request 就对了。</p><h2 id="4-配置-Nginx"><a href="#4-配置-Nginx" class="headerlink" title="4. 配置 Nginx"></a>4. 配置 Nginx</h2><p>毕竟要隐蔽嘛，最好是选一个已经上线的正常网站，悄咪咪地把其中一个路径反代到我们的 V2Ray 上。</p><p>网上不少 V2Ray + WebSocket + TLS 的教程里，Web 服务器 + SSL 证书的配置都是重头戏。可如果你平时就有在捣鼓网站的话，这些实在是都不算啥……所以我这里也就一笔带过了。</p><p>以 Nginx 为例，找个合适的 <code>server {}</code> 块添加以下内容（这重定向语法够蛋疼的）：</p><pre><code class="nginx">location /whatever {    proxy_redirect off;    proxy_http_version 1.1;    proxy_set_header Upgrade $http_upgrade;    proxy_set_header Connection &quot;upgrade&quot;;    proxy_set_header Host $http_host;    proxy_set_header X-Real-IP $remote_addr;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    set $is_v2ray 0;    if ($http_upgrade = &quot;websocket&quot;) {        set $is_v2ray 1;    }    if ($is_v2ray = 1) {        # 仅当请求为 WebSocket 时才反代到 V2Ray        proxy_pass http://127.0.0.1:10086;    }    if ($is_v2ray = 0) {        # 否则显示正常网页        rewrite ^/(.*)$ /mask-page last;    }}</code></pre><p>注意 <code>location</code> 的路径要和上面 V2Ray 里配置的一样。</p><p>最后完整的 Nginx 配置大概类似这样：</p><pre><code class="nginx">server {    listen 443 ssl http2;    server_name example.com;    index index.html index.htm index.php;    root /data/wwwroot/example;    ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;    ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;    ssl_session_cache shared:SSL:10m;    ssl_session_timeout 10m;    ssl_protocols TLSv1.2 TLSv1.3;    ssl_prefer_server_ciphers on;    ssl_ciphers EECDH+AESGCM:EDH+AESGCM;    location ~ [^/]\.php(/|$) {        fastcgi_pass unix:/dev/shm/php-cgi.sock;        fastcgi_index index.php;        include fastcgi.conf;    }    location /whatever {        # ...    }}</code></pre><p>表面看上去像个正常 PHP 网站，<code>/whatever</code> 里才是大有乾坤。</p><p>再把路径和网站内容搞得唬人一点，我寻思隐蔽性方面应该是没问题的。</p><h2 id="5-配置-CloudFlare"><a href="#5-配置-CloudFlare" class="headerlink" title="5. 配置 CloudFlare"></a>5. 配置 CloudFlare</h2><p>呃，这个就不用讲什么了吧。还不说声多谢 CloudFlare 哥？</p><p>CDN 配置完了再用 curl 测试一下：</p><pre><code class="bash">curl -i https://example.com/whatever</code></pre><pre><code class="plain">HTTP/2 400date: Sun, 12 Jan 2020 08:44:07 GMTcontent-type: text/plain; charset=utf-8content-length: 12sec-websocket-version: 13x-content-type-options: nosniffcf-cache-status: DYNAMICexpect-ct: max-age=604800, report-uri=&quot;https://report-uri.cloudflare.com/cdn-cgi/beacon/expect-ct&quot; server: cloudflareBad Request</code></pre><p>同样也是出现 400 Bad Request 就对了。</p><p>如果你像我上面一样在 Nginx 中配置了 <code>$http_upgrade = &quot;websocket&quot;</code> 的判断的话，这里返回的会是用于伪装的那个页面（而且 Nginx 的 <code>$http_upgrade</code> 变量不知道是按什么赋值的，直接 <code>curl --header &quot;Upgrade: websocket&quot;</code> 的话还不认，怪得很）。可以使用 <code>wscat</code> 来测试：</p><pre><code class="bash">wscat -c wss://example.com/whatever</code></pre><pre><code class="plain">Connected (press CTRL+C to quit)</code></pre><h2 id="6-配置-V2Ray-客户端"><a href="#6-配置-V2Ray-客户端" class="headerlink" title="6. 配置 V2Ray 客户端"></a>6. 配置 V2Ray 客户端</h2><p>客户端配置文件大概改成这样：</p><pre><code class="javascript">{  &quot;log&quot;: {    &quot;loglevel&quot;: &quot;warning&quot;  },  &quot;inbounds&quot;: [{    // 本地代理配置    &quot;port&quot;: 1080,    &quot;listen&quot;: &quot;127.0.0.1&quot;,    &quot;protocol&quot;: &quot;socks&quot;,    &quot;settings&quot;: {      &quot;auth&quot;: &quot;noauth&quot;,      &quot;udp&quot;: false,      &quot;ip&quot;: &quot;127.0.0.1&quot;    }  }],  &quot;outbounds&quot;: [{    &quot;protocol&quot;: &quot;vmess&quot;,    &quot;settings&quot;: {      &quot;vnext&quot;: [        {          // 套过 CloudFlare 的网址          &quot;address&quot;: &quot;example.com&quot;,          &quot;port&quot;: 443,          &quot;users&quot;: [            {              // id 和 alterId 必须和服务端上配置的一样              &quot;id&quot;: &quot;23ad6b10-8d1a-40f7-8ad0-e3e35cd38297&quot;,              &quot;alterId&quot;: 64            }          ]        }      ]    },    &quot;streamSettings&quot;: {      // 传输协议为 WebSocket      &quot;network&quot;: &quot;ws&quot;,      // 底层传输安全为 TLS      &quot;security&quot;: &quot;tls&quot;,      &quot;wsSettings&quot;: {        // 路径要和上面设置的一样        &quot;path&quot;: &quot;/whatever&quot;      }    }  }],  &quot;policy&quot;: {    &quot;levels&quot;: {      &quot;0&quot;: {&quot;uplinkOnly&quot;: 0}    }  }}</code></pre><p>上述客户端配置同样也是简化的，路由、DNS 什么的都没设置。</p><p>当然，我估计桌面用户基本上用的都是各种图形客户端，不然可不是折腾自己嘛。以 Windows 上的 v2rayN 客户端为例，你可以这样添加服务器：</p><p><img src="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2020/v2ray-ws-tls-cloudflare/v2rayn-client-ws-tls-config.png" srcset="/images/loading.jpg" data-srcset="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2020/v2ray-ws-tls-cloudflare/v2rayn-client-ws-tls-config.png" alt="v2rayn-client-ws-tls-config"></p><p>不出意外就可以正常使用了。</p><h2 id="7-后记"><a href="#7-后记" class="headerlink" title="7. 后记"></a>7. 后记</h2><p>这一套配置下来，使用体验暂且不说，隐蔽性应该是拉满的。备用梯子嘛，能在大规模断网的时候依然坚挺就算不错了。</p><p>常言道有备无患，眼见着墙越来越高，给自己多留条路子总是好的。</p><p><strong>参考链接：</strong></p><ul><li><a href="https://toutyrater.github.io/advanced/wss_and_web.html" target="_blank" rel="noopener">WebSocket+TLS+Web · V2Ray 配置指南|V2Ray 白话文教程</a></li><li><a href="https://www.v2ray.com/chapter_02/" target="_blank" rel="noopener">配置文件 · Project V 官方网站</a></li><li><a href="https://github.com/233boy/v2ray/wiki/%E4%BD%BF%E7%94%A8Cloudflare%E4%B8%AD%E8%BD%ACV2Ray%E6%B5%81%E9%87%8F" target="_blank" rel="noopener">使用Cloudflare中转V2Ray流量 · 233boy/v2ray Wiki</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2020 年的第一篇博文竟然是讲虚拟砖混结构建筑物逾越技术的，感觉有点微妙。&lt;/p&gt;
&lt;p&gt;年终总结啊，在写了在写了，明年就发。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://printempw.github.io/categories/tech/"/>
    
    
      <category term="V2Ray" scheme="https://printempw.github.io/tag/V2Ray/"/>
    
  </entry>
  
  <entry>
    <title>VS Code C/C++ 项目快速配置模板</title>
    <link href="https://printempw.github.io/vscode-cpp-project-quick-setup/"/>
    <id>https://printempw.github.io/vscode-cpp-project-quick-setup/</id>
    <published>2019-12-19T11:20:00.000Z</published>
    <updated>2019-12-19T11:20:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>去年我写过一篇博客「<a href="https://printempw.github.io/vscode-c-cpp-configuration-for-acm-oj/">使用 VS Code 搭建适用于 ACM 练习的 C/C++ 开发环境</a>」，主要介绍了在 VS Code 里跑简单 C 程序的一些方法。不过那篇文章里介绍的方法仅适用于单文件程序，所以稍微大一点的项目就力不从心了。</p><p>但是对于课程设计这类，说大不大说小也不算小的 C++ 项目，也不是特别想用大型 IDE……所以我更新了一下相关的 VSC 配置，使其也能用于多文件的 C++ 项目。</p><p>为了方便以后复用，也给其他有类似需求的人一个参考，相关的配置文件整理如下（<a href="https://gist.github.com/printempw/bcfa32a33cc268945200cb23172f262d" target="_blank" rel="noopener">Gist</a>，新建项目时复制一份到 <code>.vscode</code> 里就行了）。</p><a id="more"></a><blockquote><p>这一年来 VS Code 的 <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools" target="_blank" rel="noopener">C/C++  扩展</a> 更新了不少，还支持在 WSL 里 Remote 开发了。不过本文中还是继续以 Windows 下的 MinGW-w64 为例。WSL 的配置也差不多，有兴趣的可以看看参考链接里的官方文档。</p></blockquote><p><code>c_cpp_properties.json</code>：</p><pre><code class="javascript">{    &quot;configurations&quot;: [        {            // 配置的名称，可以添加多个在编辑器右下角切换            &quot;name&quot;: &quot;MinGW G++&quot;,            &quot;intelliSenseMode&quot;: &quot;gcc-x64&quot;,            // 这里的编译器路径，包括下面的一些选项都只是            // 给 IntelliSense 用的，和具体项目构建没关系            &quot;compilerPath&quot;: &quot;C:\\Portable\\mingw64\\bin\\g++.exe&quot;,            &quot;includePath&quot;: [                &quot;${workspaceFolder}/**&quot;            ],            &quot;defines&quot;: [],            &quot;cStandard&quot;: &quot;c11&quot;,            &quot;cppStandard&quot;: &quot;c++17&quot;        }    ],    &quot;version&quot;: 4}</code></pre><p><code>tasks.json</code>：</p><pre><code class="javascript">{    &quot;version&quot;: &quot;2.0.0&quot;,    &quot;tasks&quot;: [        {            &quot;label&quot;: &quot;compile&quot;,            &quot;type&quot;: &quot;shell&quot;,            // 拼装编译命令（以 g++ 为例）            &quot;command&quot;: &quot;g++&quot;,            &quot;args&quot;: [                &quot;-g&quot;,                &quot;-std=c++1z&quot;,                &quot;\&quot;src/*.cpp\&quot;&quot;,                &quot;-o&quot;,                &quot;\&quot;build/${workspaceFolderBasename}\&quot;&quot;            ],            &quot;options&quot;: {                // 在这个目录里执行编译命令                &quot;cwd&quot;: &quot;${workspaceFolder}&quot;,                &quot;shell&quot;: {                    // 在 PowerShell 里执行命令，否则无法识别 *.cpp                    &quot;executable&quot;: &quot;powershell.exe&quot;                }            },            &quot;presentation&quot;: {                &quot;reveal&quot;: &quot;always&quot;,                &quot;panel&quot;: &quot;shared&quot;,                &quot;focus&quot;: false,                &quot;echo&quot;: true            },            // 从编译器的输出里提取 WARNING、ERROR 等信息            &quot;problemMatcher&quot;: [&quot;$gcc&quot;],            &quot;group&quot;: {                &quot;kind&quot;: &quot;build&quot;,                &quot;isDefault&quot;: true            }        }    ]}</code></pre><p><code>launch.json</code>：</p><pre><code class="javascript">{    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [        {            // 使用 GDB 调试程序            &quot;name&quot;: &quot;(gdb) Launch&quot;,            &quot;type&quot;: &quot;cppdbg&quot;,            &quot;request&quot;: &quot;launch&quot;,            // 之前编译好的可执行文件路径            &quot;program&quot;: &quot;${workspaceFolder}/build/${workspaceFolderBasename}.exe&quot;,            &quot;args&quot;: [],            &quot;stopAtEntry&quot;: false,            // 设置 cwd 到 build 目录            &quot;cwd&quot;: &quot;${workspaceFolder}/build&quot;,            &quot;environment&quot;: [],            // 不要在集成终端里运行程序            &quot;externalConsole&quot;: true,            &quot;MIMode&quot;: &quot;gdb&quot;,            // 调试器可执行文件的路径            &quot;miDebuggerPath&quot;: &quot;C:\\Portable\\mingw64\\bin\\gdb.exe&quot;,            &quot;setupCommands&quot;: [                {                    &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,                    &quot;ignoreFailures&quot;: true                }            ],            // 调试前先运行 compile（定义在上面的 tasks.json 里）            &quot;preLaunchTask&quot;: &quot;compile&quot;        }    ]}</code></pre><p>稍微解释一下这些文件的作用。</p><p>这三个文件都是放在项目的 <code>.vscode</code> 目录下的，其中 <code>c_cpp_properties.json</code> 用于配置 VSC 的 C/C++ 扩展，<code>tasks.json</code> 配置项目的构建流程，<code>launch.json</code> 则是配置如何运行（或调试）构建好的程序。</p><p>在 VSC 内编辑这些配置文件时，鼠标移动到 JSON 的 key 上就可以查看相关配置项的说明，非常方便。另外 <code>c_cpp_properties.json</code> 这个文件，也可以通过 <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>P</kbd> 面板运行 <code>C/C++: Edit Configurations (UI)</code> 命令打开图形化配置页面。关键配置项的作用都已经在上面的注释里说明了，就不再赘述。</p><p>最终整个项目的目录结构应该是这样的：</p><pre><code class="text">$ tree -a.├── .vscode│   ├── c_cpp_properties.json│   ├── launch.json│   ├── settings.json│   └── tasks.json├── build│   └── vscode-cpp-quick-setup.exe└── src    ├── Greeter.cpp    ├── Greeter.h    └── main.cpp</code></pre><p>所有源代码放在 <code>src</code> 目录中，编译后的可执行文件将以当前 workspace 命名（一般是目录名），存放于 <code>build</code> 目录中。</p><p>另外必须吐槽的一点是，9012 年了，C/C++ 扩展还不支持「以非调试模式运行」，绝了。如果你想要不调试直接跑，可以自己新建一个 Task 来运行程序。不过这超出了本文的讨论范围，故按下不表。</p><p><img src="https://img.blessing.studio/images/2019/12/19/vscode-cpp-project.png" srcset="/images/loading.jpg" data-srcset="https://img.blessing.studio/images/2019/12/19/vscode-cpp-project.png" alt="vscode-cpp-project"></p><br><p><strong>参考链接：</strong></p><ul><li><a href="https://code.visualstudio.com/docs/languages/cpp" target="_blank" rel="noopener">C++ programming with Visual Studio Code</a></li><li><a href="https://code.visualstudio.com/docs/cpp/config-mingw" target="_blank" rel="noopener">Get Started with C++ and Mingw-w64 in Visual Studio Code</a></li><li><a href="https://code.visualstudio.com/docs/cpp/config-wsl" target="_blank" rel="noopener">Get Started with C++ and Windows Subsystem for Linux in Visual Studio Code</a></li><li><a href="https://code.visualstudio.com/docs/editor/variables-reference" target="_blank" rel="noopener">Visual Studio Code Variables Reference</a></li><li><a href="https://github.com/Microsoft/vscode-cpptools/issues/1201" target="_blank" rel="noopener">Support “Run without debugging” · Issue #1201 · microsoft/vscode-cpptools</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;去年我写过一篇博客「&lt;a href=&quot;https://printempw.github.io/vscode-c-cpp-configuration-for-acm-oj/&quot;&gt;使用 VS Code 搭建适用于 ACM 练习的 C/C++ 开发环境&lt;/a&gt;」，主要介绍了在 VS Code 里跑简单 C 程序的一些方法。不过那篇文章里介绍的方法仅适用于单文件程序，所以稍微大一点的项目就力不从心了。&lt;/p&gt;
&lt;p&gt;但是对于课程设计这类，说大不大说小也不算小的 C++ 项目，也不是特别想用大型 IDE……所以我更新了一下相关的 VSC 配置，使其也能用于多文件的 C++ 项目。&lt;/p&gt;
&lt;p&gt;为了方便以后复用，也给其他有类似需求的人一个参考，相关的配置文件整理如下（&lt;a href=&quot;https://gist.github.com/printempw/bcfa32a33cc268945200cb23172f262d&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Gist&lt;/a&gt;，新建项目时复制一份到 &lt;code&gt;.vscode&lt;/code&gt; 里就行了）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://printempw.github.io/categories/tech/"/>
    
    
      <category term="VS Code" scheme="https://printempw.github.io/tag/VS-Code/"/>
    
      <category term="C/C++" scheme="https://printempw.github.io/tag/C-C/"/>
    
  </entry>
  
  <entry>
    <title>写在思想未被戴上脚镣前</title>
    <link href="https://printempw.github.io/freedom-of-thought/"/>
    <id>https://printempw.github.io/freedom-of-thought/</id>
    <published>2019-12-18T14:55:00.000Z</published>
    <updated>2019-12-18T14:55:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天不谈技术，我们来聊一聊思想。</p><p>不过事先声明，我这人挺浅薄的，文笔也不好。各位如果看着不太开心，随时右上角没有问题。网上有一类人挺讨人厌，就是书读得少，想得又太多，还喜欢瞎 BB。希望这篇文章不会让我成为他们中的一员。</p><a id="more"></a><br><p>为什么突然想说这个呢？就是因为我看到了今天的热点新闻，复旦大学修改章程、删除「思想自由」一事。如果你对此不甚了解，可以去搜索一下。</p><p>当然我也不是复旦大学的学生，所以对此事也说不上气愤。就是感觉……很符合国情。虽然这个社会环境下产生太多有独立思考能力的学生群体可能对维稳不太好，但咱也不能这么直白呀对不对。堂堂名校，不鼓励学生自由思考，教机器人？</p><p>但毕竟章程也就是一片纸，除了明确告诉你「我不要脸了」之外，好像也没什么实际上的意义。把传统传承下去的到底还是人，不是纸片。</p><br><p>学校章程中删除了「思想自由」，学生的思想就变得不自由了吗？这话也可以反过来问，「思想自由」写入学校章程，学生的思想就是自由的了吗？</p><p>依我愚见，并非如此。</p><p>就拿政治举例。以前在网上看到过这么一个问题，问的是如何看待大学生对思政课的态度。有人回答，效果很好，完美达成了「既让学生没有思想，又让学生不关心政治」的预期目标（大意）。虽然抖机灵，但不得不说还是能说明一些问题的。</p><p>很多情况下，人们只是不去思考、囫囵地接受外界信息而已。过得好好的，为什么要去关心这些事情？有那个时间不如多关心关心自己的工作学习，晚饭吃什么，今天又有什么好玩的东西更新了。现世安稳，岁月静好。对于象牙塔中的学生们尤为如此。</p><p>在此我也无意评判普通人是否应该关心政治，这是每个人的选择，我没兴趣去干预。但相应地，你也不应该用「不要涉政」之类的话来将你的价值观强加于我，对吧。</p><p>值得庆幸的是，电幕与思想警察目前依然还只存在于架空世界中。这世道再怎么魔幻，也还没听说过有人因为脑子里想了点什么就被怎么怎么样的案例。哦，当然啦，表达自由得另说。</p><br><p>目前的社会有太多的因素迫使我们保持沉默。就拿我自己来说，我可不愿意因为大放厥词被有关部门请去喝茶。我还想顺利毕业找到工作养家糊口呢。</p><p>「如果天总也不亮，那就摸黑过生活；如果发出声音是危险的，那就保持沉默；如果自觉无力发光，那就别去照亮别人。但是——但是：不要习惯了黑暗就为黑暗辩护；不要为自己的苟且而得意洋洋；不要嘲讽那些比自己更勇敢、更有热量的人们。可以卑微如尘土，不可扭曲如蛆虫。」</p><p>选择沉默也好，不发声也没事，但不要自己给自己的思想戴上脚镣，也不要去尝试去禁锢其他人的思想。不要人云亦云，学会质疑。</p><br><p>这些年来，不仅社会新闻越来越魔幻，其下网友评论也愈发荒诞可笑起来。</p><p>如果和民主自由、法制相关，那就是其他国家难道就法制了？民主自由就一定好？看看 XX 乱成什么样了？如果批评社会制度，那就是公知、带路党，太平洋没加盖，嫌中国不好就滚出中国。论点不同就是「带节奏」，还有屡试不爽的境外势力。</p><p>我见过太多这种评论了，惹不起。况且我也自认为思想深度还不足以当个键政选手指点江山，所以我在公开表达什么观点的时候会非常 defensive。我甚至能设想出如果我这里怎样怎样写的话，某些人会怎样评论。</p><p>另外我觉得好笑而又无奈的一点就是国内媒体平台对舆论的管制。内容已被删除、禁止转发评论、帐号涉嫌违规，中国新时代互联网一道亮丽的风景线。偌大一个舆论热点可以在一天内从全网销声匿迹，然后被遗忘，仿佛从来没有发生过一样。</p><p>大家都听过「中国特色社会主义道路自信、理论自信、制度自信、文化自信」对吧？防民如防贼，在我看来，这实在是算不上什么自信。</p><p>小到社会热点，大到国家政权，难道不应该都是经得住赞美、也经得起批评的吗？只允许唱赞歌，不允许批评的声音，这才是我觉得最恐怖的地方。</p><br><p>有这么一段话我觉得很有味道，来来回回读了好多遍：</p><p>「在消灭了『尖锐』批评之后，『温和』的批评就成了最刺耳的，也会被消灭掉；在批评被消灭后，调侃又会无法容忍；在声音都被消灭之后，沉默被视为无声的反抗；接着就会要求赞美，然后再消灭那些赞美得不起劲的；最后掌声无法停下来，因为先停止鼓掌的就会先被消灭掉。」</p><p>可能会有人说我不爱国。爱国不等于爱党、爱政府，这已经是老生常谈的话题了（呃，虽然主旋律是喜欢把这几样绑在一起啦），我这里就不再多说。</p><p>如果要问我爱不爱国，那我当然是「爱」的，我还没有什么恨它的理由。所以请不要给我戴「恨国」「废青」的帽子，小的担待不起。</p><p>爱国不应该是齐齐唱颂赞美诗。我喜欢这个国家，所以我会希望它变得更好。对问题视而不见并不能解决问题，解决提出问题的人也不能解决问题。</p><br><p>有一个词叫做「房间里的大象」，说的是那些明明已经很严重了，但还是被我们忽略的问题。又或者也可以说是「我们知道，但是装作不知道」的问题。</p><p>诚然，如果我把目光从这些事件上移开，不去考虑什么猪肉、房价、毒疫苗、幼儿园，那大环境还是挺美好的。科技发达、生活便利，如此种种。</p><p>但是，我已经一度看到了那些景象，又要我怎么才能忘却呢？</p><p>中国社会习惯「明哲保身」「事不关己高高挂起」，只要没波及到自己以及家人，很多恶事看起来都是无所谓的。然而，近年来越来越多的新闻表明，这些事件离我们普通人真的很近，很有可能下一个轮到的就是自己。</p><p>Twitter 上有不少分享所谓「社会主义铁拳」的帐号，即那些平时为国家摇旗呐喊的「小粉红」们，在亲身经历恶性事件后反而无处发声的讽刺场景。很多人在评论区大呼舒适，我却是高兴不起来。我和粉红们无怨无仇，发生这种事情是社会的悲哀。</p><p>如果一直选择对屋内的大象视而不见，那当它抬起脚踩碎「岁月静好」「太平盛世」的幻觉时，恐怕就为时已晚了。</p><br><p>好了，话又说回来。即使我已经尽我所能用最温和的方式表达了观点，但不出意外我依然能被分类到「小伙子你的思想很危险」里去。</p><p>我其实是挺害怕的，考虑了一段时间要不要发出来。严格来说，我的这个身份并非完全匿名，根据至今为止透露出的信息想要特定到我个人其实也不算难事。</p><p>不过想想还是发了，老窝囊着也不是事儿。</p><p>生活给我戴上了脚镣，但至少允许我对蓝天心存向往吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天不谈技术，我们来聊一聊思想。&lt;/p&gt;
&lt;p&gt;不过事先声明，我这人挺浅薄的，文笔也不好。各位如果看着不太开心，随时右上角没有问题。网上有一类人挺讨人厌，就是书读得少，想得又太多，还喜欢瞎 BB。希望这篇文章不会让我成为他们中的一员。&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="https://printempw.github.io/categories/essay/"/>
    
    
  </entry>
  
  <entry>
    <title>Manjaro Linux 踩坑调教记录</title>
    <link href="https://printempw.github.io/setting-up-manjaro-linux/"/>
    <id>https://printempw.github.io/setting-up-manjaro-linux/</id>
    <published>2019-11-23T14:26:53.000Z</published>
    <updated>2020-01-23T10:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>去年买的游戏本重得要死，续航又差，背出去简直像个傻 X。所以这次双十一对比了一下最近的机器，新添置了一台轻薄本 —— 荣耀 MagicBook 2019 锐龙版。Ryzen 5 3500U，8 + 512G，￥3499，香疯了！AMD YES！</p><p>之前我就听说过 Manjaro 这个 Arch Linux 的衍生发行版有多么多么赞<del>（洗手.jpg）</del>，既然这次正好机器也没预装 Windows，就打算在实机上安装体验一下。这是我第一次在日常生活中使用 Linux 作为主力操作系统（以前要么是虚拟机要么是 WSL），从结果来看，不得不说实际体验还是非常不错的。</p><p>虽然 Linux 桌面对普通用户依然不友好（你看这篇文章配置各种软件写了这么长就知道了……），不过对于我这种算不上非常 geek 但还是懂一些 Linux 知识的人来说，只需要进行一番配置就能用得很舒适 —— 网页浏览、影音视听、聊天通讯、文档编辑、编程开发，实际几天日常使用下来，一点问题也没有，远超我的预期。</p><a id="more"></a><p>Manjaro 不是我第一个使用过的发行版，但绝对是我用得最爽的一个。很大一个原因就是其背靠的 Arch Linux 完善的社区与超全的软件包仓库 —— 我用到现在，几乎所有软件都是包管理器安装的，遇到的大部分问题 Wiki 里都有。再也不用像以前用 Ubuntu 系那样添加各种 PPA 或者 <code>dpkg</code>、<code>make install</code> 啦！懒人福音！</p><p>选择 Linux 发行版，其实 DE 之类的外观都是次要的（有心美化都能实现一样的效果），主要还是看它提供的软件包和社区。完善的软件生态带来的用户体验提升真的不是一点半点。比如我以前被 elementary OS 的外观吸引而使用过一段时间，好看是挺好看，但其基于 Ubuntu 的软件包管理实在是说不上舒适。</p><p>好了废话不多说，开始正文吧。本文主要记录了我在配置系统和各种软件时的过程以及遇到的坑，希望对你有所帮助。如果有什么问题，也欢迎在评论区向我提问。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Manjaro 官方提供了好几个 DE 的版本，我选择的是 GNOME 版。</p><p><a href="https://manjaro.org/download/" target="_blank" rel="noopener">https://manjaro.org/download/</a></p><p>下载 ISO 镜像制作启动盘（别用那些乱七八糟的启动盘制作工具，可能会无法启动，推荐使用 <a href="https://rufus.ie/" target="_blank" rel="noopener">Rufus</a>），从 U 盘启动一路安装就完事儿了。</p><p>需要注意的是要在 BIOS 中关闭 Secure Boot，不然会 boot failed。</p><h2 id="镜像源"><a href="#镜像源" class="headerlink" title="镜像源"></a>镜像源</h2><p>设置国内镜像源，选快的就行：</p><pre><code class="bash">sudo pacman-mirrors -c China -i -m rank</code></pre><p>archlinuxcn 软件源我没用，有需要的自己配置一下吧。</p><p>第一次滚动更新：</p><pre><code class="bash"># 同步包数据库并升级所有软件包sudo pacman -Syu</code></pre><h2 id="HiDPI"><a href="#HiDPI" class="headerlink" title="HiDPI"></a>HiDPI</h2><p>本子是 13 寸 1080P 屏，不缩放狗眼要瞎的。</p><p>GNOME 对于 HiDPI 的支持似乎还是不怎么样，显示配置里屏幕缩放只能 100%、200% 地调节。查了不少资料，有说先放大到 200% 再用 <code>xrandr --output eDP --scale 1.25x1.25</code> 缩小，但实际测试效果很糟糕。</p><p>最后测试下来直接设置字体缩放效果最好：</p><pre><code class="bash">gsettings set org.gnome.desktop.interface text-scaling-factor 1.2</code></pre><p>浏览器方面，Firefox 和 Chrome 都需要手动设置一下缩放。</p><p><strong>Firefox</strong></p><p>打开 <code>about:config</code>，设置 <code>layout.css.devPixelsPerPx</code> 为合适的数值。我设置为了 1.2。</p><p><strong>Chrome</strong></p><p>编辑 <code>~/.config/chrome-flags.conf</code> 添加如下参数：</p><pre><code>--force-device-scale-factor=1.2</code></pre><p>另外大部分 electron 程序都有自带缩放选项（VS Code、discord），可以在设置中调整。</p><h2 id="AUR"><a href="#AUR" class="headerlink" title="AUR"></a>AUR</h2><p>因为 pacman 包管理器本身并不直接支持 AUR，所以我们要装个 <a href="https://wiki.archlinux.org/index.php/AUR_helpers" target="_blank" rel="noopener">AUR helper</a>，打开通往快乐的大门。</p><p>Manjaro 自带的 pamac 图形化包管理器在设置中即可开启 AUR 支持。命令行下我选用了 <a href="https://github.com/Jguer/yay" target="_blank" rel="noopener">yay</a>，可以直接从官方 community 仓库中安装：</p><pre><code class="bash"># 后面那个是编译包时需要的一些工具，不然会报错缺少 fakeroot 之类的sudo pacman -S yay base-devel# 设置 AUR 清华镜像源yay --aururl &quot;https://aur.tuna.tsinghua.edu.cn&quot; --save# 开启 pacman 和 yay 的彩色输出sudo sed -i &quot;s/#Color/Color/g&quot; /etc/pacman.conf</code></pre><p>另附 pacman 的<a href="https://www.cnblogs.com/kirito-c/p/11181978.html" target="_blank" rel="noopener">一些基本操作</a>供参考，和 apt 还是蛮不一样的：</p><pre><code class="bash">pacman -S package_name        # 安装软件pacman -S extra/package_name  # 安装不同仓库中的版本pacman -Syu                   # 升级整个系统，y 是更新数据库，yy 是强制更新，u 是升级软件pacman -Ss string             # 在包数据库中查询软件pacman -Si package_name       # 显示软件的详细信息pacman -Sc                    # 清除软件缓存，即 /var/cache/pacman/pkg 目录下的文件pacman -R package_name        # 删除单个软件pacman -Rs package_name       # 删除指定软件及其没有被其他已安装软件使用的依赖关系pacman -Qs string             # 查询已安装的软件包pacman -Qi package_name       # 查询本地安装包的详细信息pacman -Ql package_name       # 获取已安装软件所包含的文件的列表pacman -U package.tar.zx      # 从本地文件安装pactree package_name          # 显示软件的依赖树</code></pre><p>yay 的用法与 pacman 完全类似，上述所有 <code>pacman xxx</code> 命令，均可替换成 <code>yay xxx</code> 执行。</p><p>此外，还有一条 yay 命令值得记一下：</p><pre><code class="bash">yay -c  # 卸载所有无用的依赖，类似 apt autoremove</code></pre><h2 id="加速-AUR-包构建"><a href="#加速-AUR-包构建" class="headerlink" title="加速 AUR 包构建"></a>加速 AUR 包构建</h2><p>默认情况下 <code>makepkg</code> 构建 AUR 包时会启用压缩，构建完了安装又要再解压一次，如果只是自己机器上使用的话，实在是没必要（而且大软件包压缩很慢）。</p><p>设置构建包时不进行压缩：</p><pre><code class="bash">sudo sed -i &quot;s/PKGEXT=&#39;.pkg.tar.xz&#39;/PKGEXT=&#39;.pkg.tar&#39;/g&quot; /etc/makepkg.conf</code></pre><h2 id="输入法"><a href="#输入法" class="headerlink" title="输入法"></a>输入法</h2><p>系统安装好后是没有中文输入法的，需要手动安装配置。</p><p>输入法框架个人习惯使用 fcitx，输入法则是选择了口碑很好的 Rime：</p><pre><code class="bash"># 个人还需要个日语输入法sudo pacman -S fcitx-rime fcitx-mozc# 对不同 GUI 框架的支持，全部安装sudo pacman -S fcitx-im# 图形化配置界面sudo pacman -S fcitx-configtool</code></pre><p>编辑桌面启动脚本，注册输入法模块并支持 xim 程序（有些文章会让你放到 <code>~/.xprofile</code> 里去，这之间有些差别，还是按照 Arch Wiki 上的来吧），注销重新登录后生效：</p><pre><code class="bash">vim ~/.pam_environment</code></pre><pre><code>GTK_IM_MODULE=fcitxQT_IM_MODULE=fcitxXMODIFIERS=@im=fcitx</code></pre><p>图形化配置界面中删除自带的拼音输入法，添加 Rime 与 Mozc：</p><p><img src="https://img.blessing.studio/images/2019/11/23/fcitx-gui-add-im.png" srcset="/images/loading.jpg" data-srcset="https://img.blessing.studio/images/2019/11/23/fcitx-gui-add-im.png" alt="fcitx-gui-add-im"></p><p>如果添加界面中找不到新安装的输入法，可以在菜单中重启一下 fcitx。</p><p>一些常用的默认快捷键：</p><ul><li><kbd>Ctrl</kbd> + <kbd>Space</kbd> 激活输入法</li><li><kbd>左Shift</kbd> 临时切换到英文</li><li><kbd>Ctrl</kbd> + <kbd>Shift</kbd> 输入法间切换</li><li><kbd>-</kbd> / <kbd>=</kbd> 向前/向后翻页</li><li><kbd>Shift</kbd> + <kbd>Space</kbd> 全角、半角切换</li></ul><p>本来输入法和输入方案是可以在托盘的 fcitx 图标的菜单中切换的，但是我的 GNOME 上不知道为什么打不开 dropdown 菜单（点一下马上就收起来，终极拼手速），只好手动修改配置文件了：</p><pre><code class="bash">vim ~/.config/fcitx/rime/default.custom.yaml</code></pre><pre><code>patch:  &quot;menu/page_size&quot;: 7  schema_list:    - schema: luna_pinyin_simp    - schema: luna_pinyin</code></pre><p>输入方案也可以在切换至 Rime 时按 F4 或者 <kbd>Ctrl</kbd> + <kbd>`</kbd> 切换，不过我基本只用得到这俩。</p><p>Rime 自身的具体配置这里不再赘述，实在是太复杂了，有兴趣的可以参考一下网上其他人分享的配置文件。</p><p>另外再装个输入法皮肤，不然默认的太丑：</p><pre><code class="bash">mkdir -p ~/.config/fcitx/skinyay -S fcitx-skin-material# 在图形界面中修改使用的皮肤或者手动修改配置文件vim ~/.config/fcitx/conf/fcitx-classic-ui.config</code></pre><p>看起来还不错：</p><p><img src="https://img.blessing.studio/images/2019/11/23/fcitx-change-skin-material.png" srcset="/images/loading.jpg" data-srcset="https://img.blessing.studio/images/2019/11/23/fcitx-change-skin-material.png" alt="fcitx-change-skin-material"></p><h2 id="GNOME-桌面美化"><a href="#GNOME-桌面美化" class="headerlink" title="GNOME 桌面美化"></a>GNOME 桌面美化</h2><h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><p>自从 Windows XP 以来就没怎么折腾过系统美化了……还蛮怀念的。</p><p>GNOME 换主题很方便，而且 Manjaro 预装了 GNOME Tweaks，所以装就完事儿了。<a href="https://www.gnome-look.org/" target="_blank" rel="noopener">Gnome-look.org</a> 中有很多主题，各种风格一应俱全（比如仿 macOS 的，仿 macOS 的和仿 macOS 的）。</p><p>个人很喜欢 Ubuntu 默认的 <a href="https://github.com/ubuntu/yaru/" target="_blank" rel="noopener">Yaru</a> 主题，可以直接从 AUR 安装：</p><pre><code class="bash">yay -S yaru-gnome-shell-theme yaru-gtk-theme yaru-icon-theme yaru-session</code></pre><p>在 GNOME Tweaks 里指定主题：</p><p><img src="https://img.blessing.studio/images/2019/11/23/gnome-tweaks-set-theme-yaru.png" srcset="/images/loading.jpg" data-srcset="https://img.blessing.studio/images/2019/11/23/gnome-tweaks-set-theme-yaru.png" alt="gnome-tweaks-set-theme-yaru"></p><p><del>这样配合下面的 GNOME Shell 扩展就可以实现 Ubuntu 拟态啦。（x）</del></p><p>不过 yaru-gnome-shell-theme 目前还不能直接在 Tweaks 中指定，需要在登录页面修改 session（点登录按钮旁边的齿轮图标，选择 <code>yaru-session</code>）。看 AUR 软件包评论中说后续版本会改进，期待一下。</p><h3 id="Shell-扩展"><a href="#Shell-扩展" class="headerlink" title="Shell 扩展"></a>Shell 扩展</h3><p>原生的 GNOME 桌面其实并不是很好用，但是加上了各种扩展之后就会变得很强大（包括 Dock 之类的）。你可以在 <a href="https://extensions.gnome.org/" target="_blank" rel="noopener">extensions.gnome.org</a> 中查看所有可用的扩展。</p><blockquote><p> 如果你疑惑为什么叫 Shell，gnome-shell 和 gnome-terminal 有什么区别的话，可以看看 <a href="https://printempw.github.io/the-difference-between-cli-terminal-shell-tty/">这篇文章</a>。</p></blockquote><p>Manjaro 默认安装就自带了这些 GNOME Shell 扩展：</p><ul><li><code>gnome-shell-extension-appfolders-manager</code> 支持在「应用程序」视图中给程序按文件夹分类。需要注意的是开启之后会导致 Dock 上图标无法排序、文件夹无法重命名的问题，应该是 BUG；</li><li><code>gnome-shell-extension-appindicator</code> 显示各种托盘图标；</li><li><code>gnome-shell-extension-arc-menu</code> 应用菜单，有点类似 Windows 开始菜单；</li><li><code>gnome-shell-extension-dash-to-dock</code> 喜闻乐见的 Dock；</li><li><code>gnome-shell-extension-dash-to-panel</code> 类似 Windows 的底部任务栏，取代顶栏和 Dock；</li><li><code>gnome-shell-extension-desktop-icons</code> 没错，显示桌面图标还得要个扩展……而且效果还不怎么样，你甚至不能从桌面拖拽文件到其他程序里，只能从文件管理器里拖；</li><li><code>gnome-shell-extension-gsconnect</code> KDE Connect 协议的 GNOME Shell 实现，可以连手机啥的；</li><li><code>gnome-shell-extension-openweather</code> 显示天气预报。</li></ul><p>我另外还安装了这些扩展：</p><ul><li><code>gnome-shell-extension-clipboard-indicator-git</code> 剪贴板管理；</li><li><code>gnome-shell-extension-status-area-horizontal-spacing</code> 减少顶栏图标间隔，有些主题默认的图标 padding 超大，还是紧凑点好看些。Unite 也有同样的功能，不要两个一起用；</li><li><del><code>gnome-shell-extension-topicons-redux</code> TopIcons、TopIcons Plus、TopIcons Redux……哪个能用就用哪个吧，用于集成 Wine 的托盘图标。Redux 是重构版但是目前还有点问题，装完得自己 patch 一下</del><br>（Unite 自带托盘图标功能）；</li><li><code>gnome-shell-extension-unite</code> 窗口最大化时合并顶栏与标题栏，防止出现三重额头；</li><li><a href="https://extensions.gnome.org/extension/112/remove-accesibility/" target="_blank" rel="noopener"><code>remove-accessibility</code></a> 这个目前 AUR 里还没有。开启字体缩放后（参见上面 HiDPI 配置）顶栏上会出现一个 Accessibility 的图标，还蛮烦人的，用这个把它隐藏掉。</li></ul><p>每个扩展都有不少配置（扩展开关左边的齿轮图标），调整配置上花了我不少时间。</p><p><img src="https://img.blessing.studio/images/2019/11/23/gnome-tweaks-extensions.png" srcset="/images/loading.jpg" data-srcset="https://img.blessing.studio/images/2019/11/23/gnome-tweaks-extensions.png" alt="gnome-tweaks-extensions"></p><p>最后我的桌面是这样的：</p><p><img src="https://img.blessing.studio/images/2019/11/23/my-gnome-desktop-compressed.png" srcset="/images/loading.jpg" data-srcset="https://img.blessing.studio/images/2019/11/23/my-gnome-desktop-compressed.png" alt="my-gnome-desktop"></p><h2 id="常用软件"><a href="#常用软件" class="headerlink" title="常用软件"></a>常用软件</h2><p>安装一些常用软件（基本全都可以在官方源或者 AUR 中找到）：</p><ul><li><code>visual-studio-code-bin</code> 爽死了</li><li><code>guake</code> <del>挂科</del> 雷神终端，快捷键呼出很好用</li><li><code>gimp</code> 图像编辑</li><li><code>google-chrome</code> 骂归骂，用还是要用的</li><li><code>typora</code> Markdown 编辑器，我这篇文章就是用这写的</li><li><code>flameshot</code> 截图，GNOME 自带的不太好用</li><li><code>qv2ray</code> 科学上网，SS 用户可以用 <code>shadowsocks-qt5</code> 或者  <code>electron-ssr</code></li><li><code>eog</code> 默认的图片浏览器是 gThumb，用不惯</li></ul><p>国内躲不开的 QQ 微信也可以一键安装（以 TIM 为例）：</p><pre><code class="bash"># 不要装成 deepin-wine-tim 了，那个不能用yay -S deepin.com.qq.office# 修复 TIM 字体发虚yay -S lib32-freetype2-infinality-ultimate# Wine HiDPI 缩放env WINEPREFIX=&quot;$HOME/.deepinwine/Deepin-TIM&quot; deepin-wine winecfg</code></pre><p>当然，你也可以试试之前诈尸的 Linux 版 QQ，感受一下复古风格：</p><pre><code class="bash">yay -S linuxqq</code></pre><p>再装个 WPS，实际使用下来确实挺良心的：</p><pre><code class="bash">yay -S wps-office wps-office-fonts wps-office-mime ttf-wps-fonts</code></pre><p>Manjaro 自带了思源系列字体（Noto 家族），补个 Emoji：</p><pre><code class="bash">yay -S noto-fonts-emoji</code></pre><p>修复有的 Emoji 显示为黑白符号的问题（<a href="https://github.com/stove-panini/fontconfig-emoji/" target="_blank" rel="noopener">ref</a>）：</p><blockquote><p>可能会造成 Powerline 中的 ✔ 等字符显示异常（变成彩色 emoji），有时间再研究下。</p></blockquote><pre><code class="bash">mkdir -p ~/.config/fontconfig/conf.d/cd ~/.config/fontconfig/conf.d/wget https://github.com/stove-panini/fontconfig-emoji/raw/master/69-emoji.confwget https://github.com/stove-panini/fontconfig-emoji/raw/master/70-no-dejavu.conf</code></pre><p>如果要装 Source Hans Sans/Serif 的，注意一下几个版本的区别：</p><pre><code class="bash"># CN 的是 Region-Specific Release，字库较小# Source Hans Sans CN 和 Source Hans Sans SC/TC/... 的区别adobe-source-han-sans-cn-fontsadobe-source-han-sans-otc-fontsadobe-source-han-serif-cn-fontsadobe-source-han-serif-otc-fonts</code></pre><p>再来装一些命令行工具：</p><ul><li><code>tldr</code> 简化版文档，谁用谁知道</li><li><code>proxychains</code> 解决命令行程序挂代理的老大难问题（<a href="https://github.com/rofl0r/proxychains-ng/issues/199#issuecomment-340183417" target="_blank" rel="noopener">对 Go 编写的程序无效</a>）</li><li><code>oh-my-zsh</code> 简化 zsh 的配置，离不开这玩意儿</li><li><code>zsh-theme-powerlevel9k</code> Powerline 主题</li><li><code>autojump</code> 不用再 cd 一长串进目录啦</li><li><code>zsh-autosuggestion</code> 命令自动补全</li><li><code>zsh-syntax-highlighting</code> 命令行语法高亮</li><li><code>fzf</code> 确实是模糊搜索神器</li><li><code>trash-cli</code> 直接 rm 是坏文明，最少也要 <code>alias rm=&quot;rm -iv&quot;</code></li><li><code>thefuck</code> 命令打错了？fuck 一下解解压</li><li><code>python-lolcat</code> 要 lolcat 不要 Ruby</li></ul><h2 id="触摸板手势"><a href="#触摸板手势" class="headerlink" title="触摸板手势"></a>触摸板手势</h2><p>习惯了 Windows 上四指下划显示桌面，Linux 上也设置一下。</p><p>安装 <code>libinput-gestures</code> 触摸板手势支持：</p><pre><code class="bash">yay -S libinput-gesturessudo gpasswd -a $USER inputlibinput-gestures-setup startcp /etc/libinput-gestures.conf ~/.config/libinput-gestures.conf</code></pre><p>编辑配置文件：</p><pre><code class="bash">vim ~/.config/libinput-gestures.conf</code></pre><pre><code># 四指上划下划，Super+D 我在 GNOME 中设置了「显示隐藏所有窗口」快捷键gesture swipe up 4 xdotool key super+dgesture swipe down 4 xdotool key super+d# 双指缩放，实际体验效果并不好gesture pinch in 2 xdotool key ctrl+minusgesture pinch out 2 xdotool key ctrl+plus</code></pre><p>重新启动并设置自动启动：</p><pre><code class="bash">libinput-gestures-setup restartlibinput-gestures-setup autostart</code></pre><h2 id="鼠标滚轮速度"><a href="#鼠标滚轮速度" class="headerlink" title="鼠标滚轮速度"></a>鼠标滚轮速度</h2><p>默认情况下鼠标滚轮速度太慢了，调快一点。安装 imwheel：</p><pre><code class="bash">yay -S imwheel</code></pre><p>配置（最后的 3 就是 3 倍速度）：</p><pre><code class="bash">vim ~/.imwheelrc</code></pre><pre><code>&quot;.*&quot;None,      Up,   Button4, 3None,      Down, Button5, 3</code></pre><p>启动：</p><pre><code class="bash">imwheel</code></pre><p>可以正常使用的话参见 <a href="https://wiki.archlinux.org/index.php/IMWheel#Run_IMWheel_on_startup" target="_blank" rel="noopener">Arch Wiki 添加启动项</a>。</p><p>不知道是不是实现原理的关系，imwheel 运行之后触摸板滚动会变得很奇怪……按需使用吧。</p><h2 id="笔记本合盖行为"><a href="#笔记本合盖行为" class="headerlink" title="笔记本合盖行为"></a>笔记本合盖行为</h2><p>一般来说默认就够用了，外接显示器时合盖也不挂起（睡眠）：</p><pre><code class="bash">sudo vim /etc/systemd/logind.conf</code></pre><pre><code>HandleLidSwitch=suspendHandleLidSwitchExternalPower=suspendHandleLidSwitchDocked=ignore</code></pre><p>如果只是想要合盖不挂起的话，GNOME Tweaks 里也可以设置，注意不要重复设置了。</p><h2 id="杂项配置"><a href="#杂项配置" class="headerlink" title="杂项配置"></a>杂项配置</h2><p>图形界面用中文，命令行界面用英文。在 <code>~/.zshrc</code> 中添加：</p><pre><code class="bash">export LANG=en_US.utf8export LC_TIME=en_US.UTF-8</code></pre><p>但是这样的话在终端中程序时打开的界面也会是英文，如果想用中文界面的话可以设置一下 alias：</p><pre><code class="bash">alias typora=&quot;LANG=zh_CN.UTF-8 typora&quot;alias code=&quot;LANG=zh_CN.UTF-8 code&quot;</code></pre><p>修改 home 中的中文目录名称为英文（<code>~/图片</code> 修改成 <code>~/Pictures</code>）：</p><pre><code class="bash">export LANG=en_US.utf8xdg-user-dirs-gtk-update</code></pre><p>也可以手动修改：</p><pre><code class="bash">vim ~/.config/user-dirs.dirs</code></pre><pre><code class="bash">XDG_DESKTOP_DIR=&quot;$HOME/Desktop&quot;XDG_DOWNLOAD_DIR=&quot;$HOME/Downloads&quot;XDG_TEMPLATES_DIR=&quot;$HOME/Templates&quot;XDG_PUBLICSHARE_DIR=&quot;$HOME/Public&quot;XDG_DOCUMENTS_DIR=&quot;$HOME/Documents&quot;XDG_MUSIC_DIR=&quot;$HOME/Music&quot;XDG_PICTURES_DIR=&quot;$HOME/Pictures&quot;XDG_VIDEOS_DIR=&quot;$HOME/Videos&quot;</code></pre><p>移除 Manjaro 自带的浏览器设置包（会修改主页添加书签等）：</p><pre><code class="bash">sudo pacman -R manjaro-browser-settings</code></pre><h2 id="Win10-双系统"><a href="#Win10-双系统" class="headerlink" title="Win10 双系统"></a>Win10 双系统</h2><p>虽然 Manjaro 很好用，但有时候某些东西只能在 Windows 下跑，还是装个双系统备用吧。</p><p>注意：后文均以 UEFI + GPT 为例。（我寻思这年头 Legacy BIOS + MBR 的选手应该也没多少了）</p><h3 id="备份-Linux"><a href="#备份-Linux" class="headerlink" title="备份 Linux"></a>备份 Linux</h3><p>虽然基本不会出什么问题，不过为了以防万一还是全盘备份一下。</p><p>Manjaro 预装了 Timeshift 备份工具，使用起来很方便，我在移动硬盘上分了一个 ext4 来存放系统备份。当然你也可以<a href="https://wiki.archlinux.org/index.php/Rsync#Full_system_backup" target="_blank" rel="noopener">手动 rsync</a> 或者用其他你喜欢的备份方式。</p><h3 id="硬盘分区"><a href="#硬盘分区" class="headerlink" title="硬盘分区"></a>硬盘分区</h3><p>分一块 NTFS 出来给 Windows 安装就行了，用 GParted 还是什么随你。</p><pre><code class="plain">[printempw@magicbook ~]$ lsblkNAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTnvme0n1     259:0    0   477G  0 disk├─nvme0n1p1 259:1    0   300M  0 part /boot/efi├─nvme0n1p2 259:2    0    50G  0 part /├─nvme0n1p3 259:3    0   200G  0 part /home├─nvme0n1p4 259:4    0     8G  0 part [SWAP]└─nvme0n1p5 259:5    0 218.7G  0 part</code></pre><h3 id="安装-Windows"><a href="#安装-Windows" class="headerlink" title="安装 Windows"></a>安装 Windows</h3><p>Rufus 制作 Windows 安装启动盘，安装至分好的 NTFS 分区一路无脑 Next。</p><h3 id="修复引导"><a href="#修复引导" class="headerlink" title="修复引导"></a>修复引导</h3><p>不出意外 Windows 就装好了，然后你会发现你进不去 Manjaro 了 —— 开机直接进 Windows。这是因为安装了 Windows 之后它会修改 UEFI 引导顺序，优先引导 Windows Boot Manager。而 Windows Boot Manager 不能引导 Linux，所以你就进不去系统了。但是你的 Linux 文件什么的都还在，不要慌。</p><p>这里先给出解决方法。</p><p>开机按 F12 键打开 UEFI 引导菜单，除了最上面的 Windows Boot Manager 之外应该还有一个启动项（不知道为什么我的机器上不显示其他启动项的名字……），选择它应该就可以进入 Manjaro 系统了：</p><p><img src="https://img.blessing.studio/images/2019/11/23/uefi-boot-menu-f12.png" srcset="/images/loading.jpg" data-srcset="https://img.blessing.studio/images/2019/11/23/uefi-boot-menu-f12.png" alt="uefi-boot-menu-f12"></p><p>如果你愿意，可以一直像这样通过 UEFI 引导菜单来启动双系统（事实上这也是现在的主流做法）。</p><p>不过我们的主力系统是 Manjaro，而且 Windows Boot Manager 又不能引导 Linux，所以还是把默认启动项改回我们熟悉的 GRUB 更好。</p><p>UEFI 启动序列可以直接在 Windows 下使用 BOOTICE 编辑：</p><p><img src="https://img.blessing.studio/images/2019/11/23/uefi-boot-entries-after-win10-installation.png" srcset="/images/loading.jpg" data-srcset="https://img.blessing.studio/images/2019/11/23/uefi-boot-entries-after-win10-installation.png" alt="uefi-boot-entries-after-win10-installation"></p><p>也可以在 Linux 下通过 <code>efibootmgr</code> 来编辑：</p><pre><code class="plain">[printempw@magicbook ~]$ efibootmgrBootCurrent: 0001Timeout: 0 secondsBootOrder: 0000,0001,2001,0003,2002,2003Boot0000* ManjaroBoot0001* rEFInd Boot ManagerBoot0003* Windows Boot ManagerBoot2001* EFI USB DeviceBoot2002* EFI DVD/CDROMBoot2003* EFI Network[printempw@magicbook ~]$ sudo efibootmgr --bootorder 0000,2001,0001,0003,2002,2003BootCurrent: 0000Timeout: 0 secondsBootOrder: 0000,2001,0001,0003,2002,2003Boot0000* ManjaroBoot0001* rEFInd Boot ManagerBoot0003* Windows Boot ManagerBoot2001* EFI USB DeviceBoot2002* EFI DVD/CDROMBoot2003* EFI Network</code></pre><p>更新一下 GRUB 让它可以引导 Windows：</p><pre><code class="bash">sudo update-grub</code></pre><p><img src="https://img.blessing.studio/images/2019/11/23/grub-win10-dual-boot.png" srcset="/images/loading.jpg" data-srcset="https://img.blessing.studio/images/2019/11/23/grub-win10-dual-boot.png" alt="grub-win10-dual-boot"></p><blockquote><p>如果想要 <code>update-grub</code> 不自动检测其他操作系统的启动项，可以这样运行：<code>sudo GRUB_DISABLE_OS_PROBER=true update-grub</code>。永久禁止检测需编辑 <code>/etc/default/grub</code>。</p></blockquote><h3 id="一些扩展知识"><a href="#一些扩展知识" class="headerlink" title="一些扩展知识"></a>一些扩展知识</h3><p>知其然，还要知其所以然。为什么这样就能修复引导呢？</p><p>在开始之前，先来了解一下 UEFI 引导操作系统的一些基础知识。</p><blockquote><p>简单来说就是，EFI 相当于开机后运行的一个小型嵌入式系统，该系统的作用就是检查并启动我们需要的目标操作系统。EFI 的内部引导管理器管理着一个所有引导项的列表。可在开机加电后按 F12 键打开引导设备管理器查看列表。设置了默认启动项之后，开机 EFI 做相应检查后就直接交接给该默认启动项，比如 Windows 启动管理器或者 GRUB 启动菜单。在 Linux 上还可以通过命令行应用 <code>efibootmgr</code> 来访问和有限操作 EFI 内部引导管理器。</p><p>安装操作系统的时候系统需要为自己准备加载项，都需要将系统引导工具（或叫「引导加载器(boot loader)」如 Windows 启动管理器和 Grub 2 启动加载器）安装到 EFI 分区（ESP）。默认情况下，Windows 和 openSUSE 分别是 <code>/EFI/Microsoft/Boot/BCD.efi</code> 和 <code>/EFI/opensuse/grubx64.efi</code> (启用 Secure Boot 的话则是 <code>shim.efi</code>)。安装完了之后还需要向 EFI 注册成为内部引导管理器中的一个引导项后才会被 EFI 在用户开机后按 F12 键时展示给用户。如果设为默认，EFI 则会直接将后续的引导权交给该默认启动项而不会展示所有启动项列表。</p><p><em>引用自：<a href="https://cnzhx.net/blog/restore-grub2-boot-menu-with-uefi/" target="_blank" rel="noopener">恢复 UEFI 模式的 GRUB2 启动项 | 水景一页</a></em></p></blockquote><p>理解了这个，就可以理解上面我们为什么要那么做了。</p><p>先来看看 EFI 分区里面都有啥：</p><pre><code class="plain">[printempw@magicbook ~]$ sudo tree -L 3 /boot/efi/boot/efi├── EFI│   ├── boot│   │   └── bootx64.efi│   ├── Insyde│   ├── Manjaro│   │   └── grubx64.efi│   ├── Microsoft│   │   ├── Boot│   │   └── Recovery│   ├── refind│   │   ├── BOOT.CSV│   │   ├── drivers_x64│   │   ├── icons│   │   ├── keys│   │   ├── refind.conf│   │   ├── refind_x64.efi│   │   └── themes│   ├── tools│   └── UpdateCapsule└── System Volume Information</code></pre><p>安装完 Windows 之后，它会向 EFI 注册一个引导项，告诉 EFI 从哪块硬盘、哪个分区、哪个 <code>.efi</code> 文件引导系统（比如我的机器上就是 <code style="word-break: break-word;">Windows Boot Manager  HD(1,GPT,{UUID},0x1000,0x96000)/File(\EFI\Microsoft\Boot\bootmgfw.efi)</code>），然后把这个引导项的优先级设置成最高。这样一来默认情况下就是开机直接进 Windows 了，也就是我们碰到的情况。</p><p>不过我们之前安装 Manjaro 的时候，也向 EFI 注册了一个引导项（<code style="word-break: break-word;">Manjaro    HD(1,GPT,{UUID},0x1000,0x96000)/File(\EFI\Manjaro\grubx64.efi)</code>）。Windows 再怎么流氓也不会把我们已经添加了的引导项给删掉，所以按 F12 选择原来的引导项之后还是可以进去 Manjaro 的。</p><p>如果你继续安装其他的系统或者引导器（比如说我安装了 rEFInd），就会在 <code>EFI</code> 目录里继续添加文件，然后注册引导项，显示在 F12 UEFI 启动菜单中供用户选择。</p><p>这样一来是不是就能理解了呢？</p><h2 id="双系统时间不同步"><a href="#双系统时间不同步" class="headerlink" title="双系统时间不同步"></a>双系统时间不同步</h2><p>这也是老生常谈的问题了，Linux 认为硬件时钟是 UTC 的，而 Windows 认为硬件时钟是本地时区的。</p><p>所以解决方法也有两种，一种是让 Linux 认为硬件时钟是本地时间：打开 Manjaro Settings Manager，在「时间和日期」中勾选「本地时区的硬件时钟」。</p><p><img src="https://img.blessing.studio/images/2019/11/23/manjaro-settings-manager-set-local-rtc.png" srcset="/images/loading.jpg" data-srcset="https://img.blessing.studio/images/2019/11/23/manjaro-settings-manager-set-local-rtc.png" alt="manjaro-settings-manager-set-local-rtc"></p><blockquote><p>吐个槽：就拿这个界面举例说吧，不知道为什么明明 Kvantum 中设置了 Yaru 主题，QT 程序的标题栏却是亮色风格的，而标题栏里的文本又是白色，很怪。GNOME Tweaks 中设置应用程序主题为 Yaru-dark 或者 Yaru-light 时都正常，设置成 Yaru 时 QT 程序的标题栏就变成缝合怪了，搞不懂。</p></blockquote><p>另一种是让 Windows 认为硬件时钟是 UTC，修改一下注册表即可：</p><pre><code>reg add &quot;HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\TimeZoneInformation&quot; /v RealTimeIsUniversal /d 1 /t REG_QWORD /f</code></pre><p>反正两边同步就行，我选择了后者。</p><h2 id="双系统共用蓝牙设备"><a href="#双系统共用蓝牙设备" class="headerlink" title="双系统共用蓝牙设备"></a>双系统共用蓝牙设备</h2><p>网上教程很多，不再赘述。</p><h2 id="MagicBook-的一些坑"><a href="#MagicBook-的一些坑" class="headerlink" title="MagicBook 的一些坑"></a>MagicBook 的一些坑</h2><p>另外说一下 MagicBook 锐龙版在 Linux 下的坑。</p><p>首先就是这块 WLAN 蓝牙二合一无线网卡 Realtek 8822CE。i5 版的机器好像是配的 Intel 的无线网卡，锐龙版的就变成螃蟹家的了。WLAN 的话 5.2 以后的内核自带驱动，所以 Manjaro 上使用起来没什么问题，但蓝牙目前还是无法驱动。</p><p>好笑的是，机器预装的 Deepin Linux 专业版还是用的 5.0 内核，虽然预装版本的系统里也有预装驱动，但如果你重装一下 Deepin，<a href="https://github.com/linuxdeepin/internal-discussion/issues/2425" target="_blank" rel="noopener">就会惊喜地发现无线网卡用不了啦</a>。蓝牙无法使用的问题华为官方倒是也 <a href="https://cn.ui.vmall.com/thread-21831568-1-1.html" target="_blank" rel="noopener">更新了 Linux 驱动</a>，然而所谓的更新就是提供了个编译好的 .ko 文件，还只适配 Deepin 的 5.0.0-13-generic 内核，服了。好在这本子可以换网卡，实在不行就只能拆机换块 Intel 的无线网卡了。</p><p>顺带一提这网卡在 Windows 下也是无法免驱的，用原版 Windows 镜像安装的同学记得准备驱动。京东上买预装 Linux 版的 MagicBook 官方还会送个傻瓜式装 Windows 的 U 盘（真的傻瓜式，启动就开始安装，差点把我硬盘整个格掉），可以从里面直接获取需要的驱动程序。</p><p>另外还有指纹识别目前也无法驱动（<code>ID 27c6:5117 Shenzhen Goodix Technology Co.,Ltd. Goodix Fingerprint Device</code>），不知道什么时候能支持。Windows Hello 的指纹识别体验确实很不错。</p><p>其他基本上没什么问题了，用得很满意，毕竟这价格还要啥自行车是吧。</p><blockquote><p>更新：就算在 Windows 下有驱动，MagicBook 锐龙版在同时使用蓝牙与 2.4GHz WiFi 的时候网络丢包也非常严重。此问题并非个例，华为论坛上也是一片骂声。虽然可以通过拆机更换无线网卡解决，不过有意愿购买的还是再考虑一下吧。</p><p>再次更新：我已经拆机更换 Intel AX200 网卡了，再您🐴的见。</p></blockquote><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://wiki.archlinux.org/index.php/Pacman" target="_blank" rel="noopener">pacman - ArchWiki</a></li><li><a href="https://wiki.archlinux.org/index.php/HiDPI" target="_blank" rel="noopener">HiDPI - ArchWiki</a></li><li><a href="https://wiki.archlinux.org/index.php/Fcitx" target="_blank" rel="noopener">Fcitx - ArchWiki</a></li><li><a href="https://wiki.archlinux.org/index.php/System_time" target="_blank" rel="noopener">System time - ArchWiki</a></li><li><a href="https://forum.manjaro.org/t/howto-dual-boot-manjaro-windows-10-step-by-step/52668" target="_blank" rel="noopener">[HowTo] Dual-boot Manjaro - Windows 10 - Step by Step</a></li><li><a href="https://forum.manjaro.org/t/using-livecd-v17-0-1-and-above-as-grub-to-boot-os-with-broken-bootloader/24916" target="_blank" rel="noopener">Using livecd v17.0.1 (and above) as grub to boot OS with broken bootloader</a></li><li><a href="https://cnzhx.net/blog/restore-grub2-boot-menu-with-uefi/" target="_blank" rel="noopener">恢复 UEFI 模式的 GRUB2 启动项</a></li><li><a href="https://blog.kaaass.net/archives/1205" target="_blank" rel="noopener">Arch Linux (Manjaro) 配置与常用软件安装指南</a></li><li><a href="http://bbs.wuyou.net/forum.php?mod=viewthread&tid=303679" target="_blank" rel="noopener">关于 Windows Boot Manager、Bootmgfw.efi、Bootx64.efi、bcdboot.exe 的详解</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;去年买的游戏本重得要死，续航又差，背出去简直像个傻 X。所以这次双十一对比了一下最近的机器，新添置了一台轻薄本 —— 荣耀 MagicBook 2019 锐龙版。Ryzen 5 3500U，8 + 512G，￥3499，香疯了！AMD YES！&lt;/p&gt;
&lt;p&gt;之前我就听说过 Manjaro 这个 Arch Linux 的衍生发行版有多么多么赞&lt;del&gt;（洗手.jpg）&lt;/del&gt;，既然这次正好机器也没预装 Windows，就打算在实机上安装体验一下。这是我第一次在日常生活中使用 Linux 作为主力操作系统（以前要么是虚拟机要么是 WSL），从结果来看，不得不说实际体验还是非常不错的。&lt;/p&gt;
&lt;p&gt;虽然 Linux 桌面对普通用户依然不友好（你看这篇文章配置各种软件写了这么长就知道了……），不过对于我这种算不上非常 geek 但还是懂一些 Linux 知识的人来说，只需要进行一番配置就能用得很舒适 —— 网页浏览、影音视听、聊天通讯、文档编辑、编程开发，实际几天日常使用下来，一点问题也没有，远超我的预期。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://printempw.github.io/categories/tech/"/>
    
    
      <category term="Linux" scheme="https://printempw.github.io/tag/Linux/"/>
    
      <category term="Manjaro" scheme="https://printempw.github.io/tag/Manjaro/"/>
    
  </entry>
  
  <entry>
    <title>Windows Terminal 安装与配置指南</title>
    <link href="https://printempw.github.io/windows-terminal-setup-guide/"/>
    <id>https://printempw.github.io/windows-terminal-setup-guide/</id>
    <published>2019-10-14T12:08:00.000Z</published>
    <updated>2020-03-14T15:35:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>自今年微软开发者大会 Build 2019 中<a href="https://devblogs.microsoft.com/commandline/introducing-windows-terminal/" target="_blank" rel="noopener">首次亮相</a>以来，经历了近半年的发展，万众瞩目的 Windows Terminal 已经日趋成熟。从十月份开始，我将其作为主力终端使用了一段时间，暂时还没遇到什么严重的问题。</p><p>为了方便其他想要试试 WT 的选手，这里我将安装配置过程中的一些步骤以及踩到的坑整理成文，希望对各位有所帮助。</p><a id="more"></a><h2 id="1-WT-好处都有啥？"><a href="#1-WT-好处都有啥？" class="headerlink" title="1. WT 好处都有啥？"></a>1. WT 好处都有啥？</h2><p>根据官方介绍，Windows Terminal 是一个面向命令行用户的全新、现代化、功能丰富的高性能终端应用程序。它在实现了社区用户热切期望的许多功能的同时（包括多标签页、富文本、全球化、可配置性、对主题与样式的支持等），依然保持快速与高效，不会消耗大量的内存或电量。</p><blockquote><p>不清楚什么是终端？来看看这篇博客吧：<a href="https://printempw.github.io/the-difference-between-cli-terminal-shell-tty/">命令行界面 (CLI)、终端 (Terminal)、Shell、TTY，傻傻分不清楚？</a></p></blockquote><p>说得挺唬人，不过到底也就是一个终端模拟器，玩不出什么花儿来。终端一抓一大把，mintty、ConEmu、Hyper、Terminus……有什么特别的理由用 WT 吗？</p><p>在我看来，WT 的一些特性更偏向于「润物细无声」型。比如基于 DirectX 的字体渲染引擎，原生支持 Unicode 字符、Emoji、连字等，虽然不起眼，但确确实实地提升了用户体验。而且……亚克力背景真的很好看呀！<del>好看是第一生产力嘛</del></p><p>作为微软团队主导开发的开源项目，我对其还是抱有很大信心的。</p><h2 id="2-总之先安装"><a href="#2-总之先安装" class="headerlink" title="2. 总之先安装"></a>2. 总之先安装</h2><p><strong>注意：Windows Terminal 要求 Windows 10 1903 (build 18362) 及以上版本。</strong></p><p>WT 现在已经上架 <a href="https://www.microsoft.com/store/apps/9n0dx20hk701?cid=storebadge&ocid=badge" target="_blank" rel="noopener">Microsoft Store</a>，所以直接在商店里搜索安装即可。</p><p><img src="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2019/windows-terminal-setup-guide/windows-terminal-microsoft-store.png" srcset="/images/loading.jpg" data-srcset="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2019/windows-terminal-setup-guide/windows-terminal-microsoft-store.png" alt="windows-terminal-microsoft-store"></p><p>如果你无法使用 Microsoft Store，也可以下载 <a href="https://github.com/microsoft/terminal/releases" target="_blank" rel="noopener">releases</a> 页面打包好的 <code>.msixbundle</code> 手动安装（记得先安装依赖库 <a href="https://www.microsoft.com/en-us/download/details.aspx?id=53175" target="_blank" rel="noopener">Desktop Bridge VC++ v14 Redistributable Package</a>）。</p><p>也可以使用 Chocolatey 包管理器来安装：</p><pre><code class="sh">choco install microsoft-windows-terminal</code></pre><p>或者使用 Scoop 安装（通过 <a href="https://github.com/h404bi" target="_blank" rel="noopener">@h404bi</a> 维护的第三方 bucket）：</p><pre><code class="sh">scoop bucket add dorado https://github.com/h404bi/doradoscoop install windowsterminal</code></pre><p>如果你愿意，你还可以手动编译安装，具体请参考 <a href="https://github.com/microsoft/terminal/blob/master/README.md#developer-guidance" target="_blank" rel="noopener">官方文档</a>。</p><h2 id="3-配置"><a href="#3-配置" class="headerlink" title="3. 配置"></a>3. 配置</h2><p>安装完成之后，WT 默认是长这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2019/windows-terminal-setup-guide/windows-terminal-default-look.png" srcset="/images/loading.jpg" data-srcset="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2019/windows-terminal-setup-guide/windows-terminal-default-look.png" alt="windows-terminal-default-look"></p><p>是不是感觉没什么出彩的？让我们给它打扮打扮！</p><blockquote><p><strong>2020/03/14 更新</strong>：现在 Windows Terminal 自带 Cascadia Code 字体，开箱颜值就挺高了。而且这字体我很喜欢，Linux 上作为终端字体也很好看。</p></blockquote><h3 id="3-1-配置文件简介"><a href="#3-1-配置文件简介" class="headerlink" title="3.1 配置文件简介"></a>3.1 配置文件简介</h3><p>目前（截至 2019 年 10 月 <del>2020 年 3 月也一样</del>），我们只能通过 <code>profiles.json</code> 配置文件来配置 Windows Terminal。</p><p>在标签右侧的下拉菜单中点击「Settings」，即可用你默认的 <code>.json</code> 文件编辑器打开配置文件。该文件的实际位置在这里：</p><pre><code class="plain">%localappdata%\Packages\Microsoft.WindowsTerminal_8wekyb3d8bbwe\LocalState\profiles.json</code></pre><p>按住 Alt 键再点击「Settings」，可以打开默认的配置文件 <code>defaults.json</code>。你可以将其作为参考修改 <code>profiles.json</code>，但注意不要直接修改 <code>defaults.json</code>，因为对其做出的改动均不会被保留。</p><p><img src="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2019/windows-terminal-setup-guide/opening-wt-profile-json.png" srcset="/images/loading.jpg" data-srcset="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2019/windows-terminal-setup-guide/opening-wt-profile-json.png" alt="opening-wt-profile-json"></p><p>下面我会简单描述一下各配置项的作用，如果想要更详细地了解，请参考官方文档：</p><ul><li><a href="https://github.com/microsoft/terminal/blob/master/doc/user-docs/UsingJsonSettings.md" target="_blank" rel="noopener">Editing Windows Terminal JSON Settings</a></li><li><a href="https://github.com/microsoft/terminal/blob/master/doc/cascadia/SettingsSchema.md" target="_blank" rel="noopener">Profiles.json Documentation</a></li></ul><h3 id="3-2-全局配置"><a href="#3-2-全局配置" class="headerlink" title="3.2 全局配置"></a>3.2 全局配置</h3><p>这里仅介绍些常用配置，剩下的看上面的文档去罢。</p><pre><code class="json">{    // 默认打开的 Profile GUID（下面会详细介绍）    &quot;defaultProfile&quot;: &quot;{e1e1ac58-02c1-456a-a857-01149673a65d}&quot;,    // 终端窗口默认大小    &quot;initialCols&quot;: 120,    &quot;initialRows&quot;: 30,    // 亮色或暗色主题，可选值 &quot;light&quot;, &quot;dark&quot;, &quot;system&quot;    &quot;requestedTheme&quot;: &quot;system&quot;,    // 合并标题栏和标签栏    &quot;showTabsInTitlebar&quot;: true,    // 如果 showTabsInTitlebar 与本值同为 false 时，自动隐藏标签栏    &quot;alwaysShowTabs&quot;: true,    // 在标题栏上显示当前活动标签页的标题    &quot;showTerminalTitleInTitlebar&quot;: true,    // 双击选择时用于分词的字符    &quot;wordDelimiters&quot;: &quot; /\\()\&quot;&#39;-.,:;&lt;&gt;~!@#$%^&amp;*|+=[]{}~?\u2502&quot;,    // 选择时复制到剪贴板    &quot;copyOnSelect&quot;: true,    // 标签页宽度不固定    &quot;tabWidthMode&quot;: &quot;titleLength&quot;,    // ...}</code></pre><h3 id="3-3-添加新-Shell"><a href="#3-3-添加新-Shell" class="headerlink" title="3.3 添加新 Shell"></a>3.3 添加新 Shell</h3><p>以 WSL 为例（虽然 WT 自带了 WSL 的 Profile，不过这里不管它）：</p><pre><code class="json">&quot;profiles&quot;: {    &quot;defaults&quot;: {        // 所有 Profile 共用的设置可以放这里，就不用写多次了        // 字体设置        &quot;fontFace&quot;: &quot;Cascadia Code&quot;,        &quot;fontSize&quot;: 11,        // 光标类型，可选值 &quot;vintage&quot; ( ▃ ), &quot;bar&quot; ( ┃ ), &quot;underscore&quot; ( ▁ ), &quot;filledBox&quot; ( █ ), &quot;emptyBox&quot; ( ▯ )        &quot;cursorShape&quot;: &quot;underscore&quot;,        // 背景亚克力透明效果（窗口失去焦点时无效）        &quot;useAcrylic&quot;: true,        &quot;acrylicOpacity&quot;: 0.8    },    &quot;list&quot;: [        {            // 每个 Profile 的唯一标识符，生成方法见下            &quot;guid&quot;: &quot;{e1e1ac58-02c1-456a-a857-01149673a65d}&quot;,            // 设置为 true 即可在新建菜单中隐藏            &quot;hidden&quot;: false,            // 名字，会显示在菜单中            &quot;name&quot;: &quot;Ubuntu&quot;,            // 启动命令行            &quot;commandline&quot;: &quot;wsl.exe&quot;,            // 启动目录            &quot;startingDirectory&quot;: &quot;.&quot;,            // 背景图片            // &quot;backgroundImage&quot; : &quot;X:\\path\\to\\background.png&quot;,            // &quot;backgroundImageOpacity&quot; : 0.5,            // &quot;backgroundImageStretchMode&quot; : &quot;uniformToFill&quot;,            // 菜单与标签中显示的图标            &quot;icon&quot;: &quot;X:\\path\\to\\ubuntu.png&quot;,            // 配色方案，见下            &quot;colorScheme&quot;: &quot;Tango Dark&quot;,            // 光标颜色            &quot;cursorColor&quot;: &quot;#FFFFFF&quot;,            // ... 其他配置请参见官方文档        }    ]}</code></pre><p>GUID 网上有很多生成器，你也可以用 PowerShell 命令生成一个：</p><pre><code class="powershell">[guid]::NewGuid()</code></pre><p>把之前的 <code>defaultProfile</code> 设置为某个 Profile 的 GUID，打开 WT、新建标签页时就会默认使用这个 Profile。</p><p>另外你可能会注意到 <code>defaults.json</code> 中有些 Profile 的 <code>icon</code> 图片路径是以 <code>ms-appx:///ProfileIcons/</code> 开头的。这是 UWP 应用的 <a href="https://docs.microsoft.com/en-us/windows/uwp/app-resources/uri-schemes" target="_blank" rel="noopener">URI Schemes</a>，<code>ms-appx:///</code> 指向的物理路径是应用的实际安装路径。</p><p>官方文档中推荐我们把自定义图标、背景图之类的放到与 <code>profiles.json</code> 同一目录里去，然后在配置中用 <code>ms-appdata:///Local/xxx</code> 的形式来引用资源。不过如果嫌麻烦的话，直接使用绝对路径也是没问题的。</p><p><img src="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2019/windows-terminal-setup-guide/windows-terminal-new-profile.png" srcset="/images/loading.jpg" data-srcset="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2019/windows-terminal-setup-guide/windows-terminal-new-profile.png" alt="windows-terminal-new-profile"></p><h3 id="3-4-调整配色"><a href="#3-4-调整配色" class="headerlink" title="3.4 调整配色"></a>3.4 调整配色</h3><p>从 <code>defaults.json</code> 中可以看出，WT 内建可用的配色方案有：<code>Campbell</code>、<code>Campbell Powershell</code>、<code>Vintage</code>、<code>One Half Dark</code>、<code>One Half Light</code>、<code>Solarized Dark</code>、<code>Solarized Light</code>。</p><p>如果你对这些都不感冒，<a href="https://github.com/mbadolato/iTerm2-Color-Schemes" target="_blank" rel="noopener">mbadolato/iTerm2-Color-Schemes</a> 这个 repo 里有超多的终端配色，总有一款适合你（而且都提供了 WT 的配置格式，复制粘贴就能直接使用）。比如说我习惯使用 Tango 配色：</p><pre><code class="json">&quot;schemes&quot;: [    {        &quot;name&quot;: &quot;Tango Dark&quot;,        &quot;black&quot;: &quot;#000000&quot;,        &quot;red&quot;: &quot;#cc0000&quot;,        &quot;green&quot;: &quot;#4e9a06&quot;,        &quot;yellow&quot;: &quot;#c4a000&quot;,        &quot;blue&quot;: &quot;#3465a4&quot;,        &quot;purple&quot;: &quot;#75507b&quot;,        &quot;cyan&quot;: &quot;#06989a&quot;,        &quot;white&quot;: &quot;#d3d7cf&quot;,        &quot;brightBlack&quot;: &quot;#555753&quot;,        &quot;brightRed&quot;: &quot;#ef2929&quot;,        &quot;brightGreen&quot;: &quot;#8ae234&quot;,        &quot;brightYellow&quot;: &quot;#fce94f&quot;,        &quot;brightBlue&quot;: &quot;#729fcf&quot;,        &quot;brightPurple&quot;: &quot;#ad7fa8&quot;,        &quot;brightCyan&quot;: &quot;#34e2e2&quot;,        &quot;brightWhite&quot;: &quot;#eeeeec&quot;,        &quot;background&quot;: &quot;#000000&quot;,        &quot;foreground&quot;: &quot;#D3D7CF&quot;    }],</code></pre><p>配上亚克力透明背景还是很好康的（背景图来自 <a href="https://twitter.com/pix_bun/status/1126230459510169600" target="_blank" rel="noopener">@pix_bun</a>）：</p><p><img src="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2019/windows-terminal-setup-guide/windows-terminal-acrylic-background.png" srcset="/images/loading.jpg" data-srcset="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2019/windows-terminal-setup-guide/windows-terminal-acrylic-background.png" alt="windows-terminal-acrylic-background"></p><h3 id="3-5-修改按键绑定"><a href="#3-5-修改按键绑定" class="headerlink" title="3.5 修改按键绑定"></a>3.5 修改按键绑定</h3><p>默认的一些热键：</p><ul><li>打开新标签页：<kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>T</kbd></li><li>使用指定 Profile 打开标签页：<kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>1...9</kbd></li><li>关闭标签页：<kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>W</kbd></li><li>前一个标签页：<kbd>Ctrl</kbd> + <kbd>Tab</kbd></li><li>后一个标签页：<kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>Tab</kbd></li><li>复制：<kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd></li><li>粘贴：<kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>V</kbd></li></ul><p>想自定义的话直接参照 <code>defaults.json</code> 修改 <code>keybindings</code> 即可。</p><h3 id="3-6-添加右键菜单"><a href="#3-6-添加右键菜单" class="headerlink" title="3.6 添加右键菜单"></a>3.6 添加右键菜单</h3><p>一个趁手的终端，很重要的一点就是能够随时呼出。目前，有这么几种快速打开 Windows Terminal 的方式：</p><ul><li><code>Win + S</code> 或者 <code>Win + R</code>，输入 <code>wt</code> 按回车；</li><li>资源管理器中按 <code>Ctrl + L</code>，输入 <code>wt -d .</code> 回车在当前目录中打开（如果设置了 <code>&quot;startingDirectory&quot;: &quot;.&quot;</code> 可以直接输入 <code>wt</code>）；</li><li>使用 <a href="https://getquicker.net/Sharedaction?code=4e7abb0c-f213-4ee4-39f5-08d7bfff7792" target="_blank" rel="noopener">Quicker</a> 或者 <a href="https://www.autohotkey.com" target="_blank" rel="noopener">AutoHotkey</a> 等第三方工具。</li></ul><p>不过我还是比较习惯传统的右键菜单「在这里打开终端」的方式。WT 目前还没有内置这一功能，想要手动添加也比较麻烦（下文参考了这个 <a href="https://github.com/microsoft/terminal/issues/1060" target="_blank" rel="noopener">issue</a> 中的方法）。</p><p>以管理员权限打开 PowerShell，运行以下命令：</p><pre><code class="powershell">$basePath = &quot;Registry::HKEY_CLASSES_ROOT\Directory\Background\shell&quot;New-Item -Path &quot;$basePath\wt&quot; -Force -Value &quot;Windows Terminal here&quot;New-ItemProperty -Path &quot;$basePath\wt&quot; -Force -Name &quot;Icon&quot; -PropertyType ExpandString -Value &quot;X:\path\to\terminal.ico&quot;New-Item -Path &quot;$basePath\wt\command&quot; -Force -Type ExpandString -Value &#39;&quot;%LOCALAPPDATA%\Microsoft\WindowsApps\wt.exe&quot; -p Ubuntu -d &quot;%V&quot;&#39;</code></pre><p>如果你足够熟练，也可以自行通过其他方式修改注册表，反正就那么些字段，路径正确就行了。Windows Terminal 的图标可以在 <a href="https://raw.githubusercontent.com/microsoft/terminal/master/res/terminal.ico" target="_blank" rel="noopener">这里</a> 获取 。</p><blockquote><p><strong>2020/03/14 更新</strong>：Windows Terminal 0.9 版本之后添加了 <code>wt.exe</code> 的<a href="https://github.com/microsoft/terminal/blob/master/doc/user-docs/UsingCommandlineArguments.md" target="_blank" rel="noopener">命令行参数</a>，可以直接指定启动目录，不需要再修改 <code>profiles.json</code> 中的 <code>startingDirectory</code> 字段了。</p></blockquote><p>另外 <code>wt.exe</code> 支持通过 <code>-p</code> 参数指定要打开的 Profile，所以除了 WSL，我还添加了一个在当前目录下打开 PowerShell 的菜单项（注册表中添加一个 <code>Extended</code> 项可以让该右键菜单项仅在按住 Shift 右键时才显示）。你甚至可以通过二级菜单的方式实现更多功能，具体可以参考上面给出的 issue 中的讨论。</p><p><img src="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2019/windows-terminal-setup-guide/windows-terminal-context-menu.png" srcset="/images/loading.jpg" data-srcset="https://cdn.jsdelivr.net/gh/printempw/printempw.github.io@source/source/_posts/2019/windows-terminal-setup-guide/windows-terminal-context-menu.png" alt="windows-terminal-context-menu"></p><h2 id="4-后记"><a href="#4-后记" class="headerlink" title="4. 后记"></a>4. 后记</h2><p>到这里，WT 就基本配置完成了，下面是闲聊时间。</p><p>我用过很多终端，Windows Terminal 虽然不错，但也没到要吹上天的地步。</p><p><strong>我认为，真正决定操作系统命令行体验的，不是终端，是 Shell。</strong>诚然，如果终端很漂亮的话，光看着也非常赏心悦目，但如果其中的 Shell 是 <code>cmd.exe</code>，那实际体验可能就令人抓狂了。</p><p>在之前<a href="https://printempw.github.io/wsl-guide/">介绍 WSL 的文章</a>中我也说过，我喜欢 WSL 的原因之一，就是它提供了一种以类 Unix 系统命令行的那一套东西去操作 Windows 的能力（比如 Bash 和各种 GNU 小工具）。PowerShell 是不错，论强大肯定不输给任何命令行 Shell，但我用不惯呀（不过最近我也有在学习）。以前的 Cygwin 等项目虽然也能达成同样的效果，但是因为其底层实现的不同，还是 WSL 来得更舒适一些。</p><p>所以当我得知 WSL2 底层实现换成了虚拟机的时候是很抗拒的。系统调用翻译层的设计不是很惊艳吗？怎么直接就变成个小 VM 了？原本 WSL 最为人称道的（至少我是如此）互操作性要怎么办？距离我接受 WSL2，看来还是需要一定的时间。</p><p>不过有一说一，Windows Terminal 还是很不错的。<del>我又是软软了</del></p><p>Microsoft，干得漂亮！❤️</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自今年微软开发者大会 Build 2019 中&lt;a href=&quot;https://devblogs.microsoft.com/commandline/introducing-windows-terminal/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;首次亮相&lt;/a&gt;以来，经历了近半年的发展，万众瞩目的 Windows Terminal 已经日趋成熟。从十月份开始，我将其作为主力终端使用了一段时间，暂时还没遇到什么严重的问题。&lt;/p&gt;
&lt;p&gt;为了方便其他想要试试 WT 的选手，这里我将安装配置过程中的一些步骤以及踩到的坑整理成文，希望对各位有所帮助。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://printempw.github.io/categories/tech/"/>
    
    
      <category term="教程" scheme="https://printempw.github.io/tag/%E6%95%99%E7%A8%8B/"/>
    
      <category term="CLI" scheme="https://printempw.github.io/tag/CLI/"/>
    
      <category term="终端" scheme="https://printempw.github.io/tag/%E7%BB%88%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>使用子文件夹管理 Hexo 文章且不改变文章永久链接</title>
    <link href="https://printempw.github.io/hexo-posts-in-subfolder/"/>
    <id>https://printempw.github.io/hexo-posts-in-subfolder/</id>
    <published>2019-10-12T19:38:00.000Z</published>
    <updated>2020-01-15T11:45:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>2020-01-15 更新</strong>：如果你只是想实现「文章源码放在子目录、永久链接保持不变」的效果，可以直接修改 <code>_config.yml</code> 中的配置：</p><pre><code class="yaml">permalink: :name/new_post_name: :year/:title.md</code></pre><p>感谢 <a href="https://skk.moe/" target="_blank" rel="noopener">@SukkaW</a> 在评论区提供的建议！</p></blockquote><p>在 Hexo 中，我们可以通过站点配置中的 <code>permalink</code> 配置项来指定文章的永久链接的格式。比如说默认值是 <code>:year/:month/:day/:title/</code>，那么一篇 slug 为 <code>hello-world</code> 的文章，最终生成的链接就是 <code>2019/10/13/hello-world/</code>。</p><p>如果你不想分得这么细，也可以根据自己的喜好 <a href="https://hexo.io/zh-cn/docs/permalinks" target="_blank" rel="noopener">自定义这个配置项</a>。本博客就将其设置为了 <code>:title/</code>，即仅使用文章的 slug 作为永久链接，更清爽一些。</p><p>但是这样一来，文章源文件的管理就有点难办了。Hexo 中所有的文章（Post layout）都存放在 <code>source/_posts</code> 目录中，如果仅使用 slug 作为文件名的话，文章一多就会出现乱成一坨的惨状 —— 只能通过文件名查找，根本无法通过日期定位文章！</p><a id="more"></a><p><img src="https://img.blessing.studio/images/2019/10/13/too-many-files-in-posts-chaos.png" srcset="/images/loading.jpg" data-srcset="https://img.blessing.studio/images/2019/10/13/too-many-files-in-posts-chaos.png" alt="too-many-files-in-posts-chaos"></p><p>但如果你在 <code>_posts</code> 目录下新建子文件夹来存放文章，比如 <code>_posts/2019/hello-world.md</code>，你就会发现，最终生成的文章链接中也会带上这个子文件夹的名称：<code>https://hexo.example/2019/hello-world/</code>。</p><p>这可咋整？难道就不能在不改变文章永久链接的情况下，把文章源文件放到子文件夹里去吗？</p><p>当然可以！Hexo 可是以灵活<del>随便</del>著称的 JavaScript 写的博客程序，那还不是想怎么魔改就怎么魔改？这里我抛砖引玉，介绍一种使用 filter 对文章永久链接进行操作的方法。其他应该也有不少方法能实现同样的效果，欢迎各位在评论区分享交流。</p><p>先贴代码（直接放到站点根目录的 <a href="https://github.com/printempw/printempw.github.io/tree/source/scripts" target="_blank" rel="noopener"><code>scripts</code></a> 文件夹中就可以了）：</p><pre><code class="js">// posts-subfolderconst { join } = require(&#39;path&#39;);const { readdirSync } = require(&#39;fs&#39;);const moment = require(&#39;moment&#39;);// 使用子文件夹管理文章且不改变文章永久链接// e.g. &quot;source/_posts/2019/slug.md&quot; =&gt; &quot;https://hexo.example/slug/&quot;hexo.extend.filter.register(&#39;post_permalink&#39;, function (permalink) {  // 想保留在文章永久链接中的子文件夹  const excludes = [];  const postDir = join(this.source_dir, &#39;_posts&#39;);  const folders = readdirSync(postDir, { withFileTypes: true })    .filter(dirent =&gt; dirent.isDirectory())    .map(dirent =&gt; dirent.name)    .filter(dir =&gt; !excludes.includes(dir));  for (const name of folders) {    if (permalink.startsWith(`${name}/`)) {      // 删除链接中的子文件夹名称      return permalink.replace(`${name}/`, &#39;&#39;);    }  }});// 使 `hexo new` 生成的文件保存至相应的年份子文件夹中// @see hexo/lib/plugins/filter/new_post_path.jshexo.extend.filter.register(&#39;new_post_path&#39;, data =&gt; {  const year = moment(data.date || Date.now()).format(&#39;YYYY&#39;);  data.path = join(year, data.slug);  return data;}, 1); // 设置为高优先级</code></pre><p>其中 <code>post_permalink</code> 和 <code>new_post_path</code> 都是 Hexo 预留的钩子，所以基本不用费什么力气（不得不说，Hexo 的插件系统设计还是很不错的，非常灵活，也埋了足够多的 filter 和 event，基本覆盖了整个生命周期）。</p><p>修改 <code>post_permalink</code> filter 传进来的值就可以直接修改最终生成的文章永久链接，所以我们直接把自定义的子文件夹从 <code>permalink</code> 中删掉，这样文章链接中就不会出现子文件夹的名称啦，非常简单粗暴。</p><pre><code class="plain">&gt; _posts $ tree.├── ...├── 2018│   ├── ...│   ├── the-difference-between-cli-terminal-shell-tty.md│   └── wsl-guide.md└── 2019    ├── disqus-migration-tools-url-mapper.md    ├── first-post-of-2019.md    └── hexo-posts-in-subfolder.md</code></pre><p>我使用了年份来组织文件，基本上就足够了<del>（反正我一年也写不了几篇）</del>。</p><p>另外附送个我批量整理源文件时用的命令：</p><pre><code class="bash"># 记得配合自己实际的 front-matter 格式修改一下哦grep -r &quot;date: &#39;2015-&quot; *.md -l | xargs mv -v -t 2015/</code></pre><p>Happy hacking.</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;2020-01-15 更新&lt;/strong&gt;：如果你只是想实现「文章源码放在子目录、永久链接保持不变」的效果，可以直接修改 &lt;code&gt;_config.yml&lt;/code&gt; 中的配置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;yaml&quot;&gt;permalink: :name/
new_post_name: :year/:title.md&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;感谢 &lt;a href=&quot;https://skk.moe/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;@SukkaW&lt;/a&gt; 在评论区提供的建议！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 Hexo 中，我们可以通过站点配置中的 &lt;code&gt;permalink&lt;/code&gt; 配置项来指定文章的永久链接的格式。比如说默认值是 &lt;code&gt;:year/:month/:day/:title/&lt;/code&gt;，那么一篇 slug 为 &lt;code&gt;hello-world&lt;/code&gt; 的文章，最终生成的链接就是 &lt;code&gt;2019/10/13/hello-world/&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果你不想分得这么细，也可以根据自己的喜好 &lt;a href=&quot;https://hexo.io/zh-cn/docs/permalinks&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;自定义这个配置项&lt;/a&gt;。本博客就将其设置为了 &lt;code&gt;:title/&lt;/code&gt;，即仅使用文章的 slug 作为永久链接，更清爽一些。&lt;/p&gt;
&lt;p&gt;但是这样一来，文章源文件的管理就有点难办了。Hexo 中所有的文章（Post layout）都存放在 &lt;code&gt;source/_posts&lt;/code&gt; 目录中，如果仅使用 slug 作为文件名的话，文章一多就会出现乱成一坨的惨状 —— 只能通过文件名查找，根本无法通过日期定位文章！&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://printempw.github.io/categories/tech/"/>
    
    
      <category term="博客" scheme="https://printempw.github.io/tag/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="Hexo" scheme="https://printempw.github.io/tag/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>使用 URL Mapper 迁移整理 Disqus 评论</title>
    <link href="https://printempw.github.io/disqus-migration-tools-url-mapper/"/>
    <id>https://printempw.github.io/disqus-migration-tools-url-mapper/</id>
    <published>2019-09-26T14:06:00.000Z</published>
    <updated>2019-09-26T14:06:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了 Disqus 提供的评论迁移工具之一，URL Mapper 的使用方法。</p><a id="more"></a><h2 id="起因与问题分析"><a href="#起因与问题分析" class="headerlink" title="起因与问题分析"></a>起因与问题分析</h2><p>Disqus 评论系统以其几乎零配置的安装方式为众人所称道。只要把后台提供的代码插入到页面 HTML 里就能加载评论区，非常方便快捷<del>（虽然被墙了）</del>。</p><p>然而，无需配置这一点也带来了些许隐患。</p><p>今天我去 Disqus 后台查看博客上的所有 thread（即一篇文章对应的评论区）时，发现其中记录的全都是些奇怪的 URL：有带着 QQ、微信各种 Query String 一大串的，有 Google 翻译的，有 Web Archive 缓存的，甚至还有不少我自己本地测试域名的，五花八门千奇百怪着实给我看呆了。</p><p><img src="https://img.blessing.studio/images/2019/09/26/disqus-discussions-weird-url.png" srcset="/images/loading.jpg" data-srcset="https://img.blessing.studio/images/2019/09/26/disqus-discussions-weird-url.png" alt="disqus-discussions-weird-url"></p><blockquote><p>顺带一提，根据不同 URL 的数量来看（比如微信的 <code>?nsukey=</code>），所有文章里被分享次数最多的是「<a href="https://printempw.github.io/why-do-shadowsocks-deprecate-ota/">为何 shadowsocks 要弃用一次性验证 (OTA)</a>」，足足有 400 多条。其他还有「<a href="https://printempw.github.io/twitter-account-has-been-locked/">Twitter 账号被锁定是种怎样的体验</a>」「<a href="https://printempw.github.io/the-difference-between-cli-terminal-shell-tty/">命令行界面 (CLI)、终端 (Terminal)、Shell、TTY，傻傻分不清楚？</a>」等文章也比较受欢迎。</p></blockquote><p>为什么会这样呢？问题就出在「无需配置也能用」上。</p><p>默认情况下，Disqus 给出的通用安装代码类似这样：</p><pre><code class="html">&lt;div id=&quot;disqus_thread&quot;&gt;&lt;/div&gt;&lt;script&gt;/***  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*//*var disqus_config = function () {this.page.url = PAGE_URL;  // Replace PAGE_URL with your page&#39;s canonical URL variablethis.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page&#39;s unique identifier variable};*/(function() { // DON&#39;T EDIT BELOW THIS LINEvar d = document, s = d.createElement(&#39;script&#39;);s.src = &#39;https://blessing-studio.disqus.com/embed.js&#39;;s.setAttribute(&#39;data-timestamp&#39;, +new Date());(d.head || d.body).appendChild(s);})();&lt;/script&gt;&lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;https://disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt;</code></pre><p>其中被注释掉的 <code>disqus_config</code> 部分是用于初始化 Disqus thread 的。虽然不配置其中的 <code>url</code> 和 <code>identifier</code> 也可以用，但是这会导致 Disqus 直接使用当前页面的完整 URL 来初始化评论区。</p><p>也就是说，如果默认情况下你没有配置这些变量，<strong>访客每通过一个新的 URL 访问你的文章（就算只有 Query String 不一样），Disqus 就会为它新建一个 thread</strong>。这就导致了<a href="https://help.disqus.com/en/articles/1717137-use-configuration-variables-to-avoid-split-threads-and-missing-comments" target="_blank" rel="noopener">官方帮助文档</a>中提到的 split threads 现象，即我上面在后台看到的一万个 thread。</p><p>至于为什么我没配置 <code>url</code> 和 <code>identifier</code>，那就得问问我当初移植旧主题时脑子放到哪里去了。¯\_(ツ)_/¯</p><p>在目前的 <a href="https://github.com/printempw/hexo-theme-murasaki" target="_blank" rel="noopener">Murasaki</a> 主题中，这两项分别被配置为文章的 permalink 与 slug。</p><h2 id="使用-URL-mapper-迁移评论"><a href="#使用-URL-mapper-迁移评论" class="headerlink" title="使用 URL mapper 迁移评论"></a>使用 URL mapper 迁移评论</h2><p>问题根源是解决了，那我们要怎么收拾这个烂摊子呢？</p><p>好在 Disqus 提供了几个工具用于迁移评论，其中的 URL Mapper 就可以让我们对 thread 进行批量操作。这个工具接受一个 CSV 格式的文件，其中包含了新旧 URL 的映射关系：<strong>将 A 映射至 B，那么 A 的评论就会被迁移到 B 上</strong>。</p><blockquote><p>其他的迁移工具还有 Domain Migration Tool 和 Redirect Crawler，分别适用于仅更改了域名以及已经配置好了 301 重定向的情况。详情可参考官方文档。</p></blockquote><p>首先打开 Disqus 后台，访问 <strong>Community &gt; Tools &gt; Migrate Threads &gt; URL Mapper</strong> 页面，点击「Start URL mapper」，即可下载一个包含了站点中全部 thread URL 的 CSV 文件（下载链接会发送到你的邮箱里）。</p><p>用文本编辑器或者其他工具打开这个 CSV，按需修改：</p><ul><li>如果想将 A 修改为 B，那么就增加一列写上 B；</li><li>如果某一行无需修改，直接删除该行即可（不要空着）；</li><li>对于那些不想要的 thread，把它们统一指向一个 404 页面就好啦。</li></ul><p>举个栗子：</p><pre><code class="csv">https://printempw.github.io/why-do-shadowsocks-deprecate-ota/?nsukey=乱七八糟一大串,https://printempw.github.io/why-do-shadowsocks-deprecate-ota/https://printempw.github.io/wsl-guide/?nsukey=乱七八糟一大串,https://printempw.github.io/wsl-guide/https://printempw.github.io/friends/index.html,https://printempw.github.io/friends/http://localhost:4000/setup-nginx-php-on-windows/,https://printempw.github.io/404.html</code></pre><p>在刚才那个页面上传修改过的 CSV，Disqus 后台就会开始迁移，迁移结束之后会有邮件提醒。</p><blockquote><p>注意！Thread 的迁移是不可逆的，提交前请务必仔细检查。</p></blockquote><p>以下是官方文档里的一些注意事项：</p><ul><li>迁移最长可能需要 24 小时完成（我半小时左右就好了）；</li><li>如果你的 CSV 文件非常大，最好把它拆分成多个文件多次迁移；</li><li>你不能将一个 thread 迁移到另一个 shortname 下去；</li><li>你可以通过映射来合并两个 URL，所有的评论都会被合并到一个 thread 中；</li><li>当两个 thread 被 URL Mapper 合并时，第二个 thread 的标题等信息会被保留。</li></ul><p>迁移之后 Discussions 页面清爽了不少，爽到。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://help.disqus.com/en/articles/1717137-use-configuration-variables-to-avoid-split-threads-and-missing-comments" target="_blank" rel="noopener">Use Configuration Variables to Avoid Split Threads and Missing Comments</a></li><li><a href="https://help.disqus.com/en/articles/1717068-migration-tools" target="_blank" rel="noopener">Migration Tools</a></li><li><a href="https://help.disqus.com/en/articles/1717129-url-mapper" target="_blank" rel="noopener">URL Mapper</a></li><li><a href="https://mycyberuniverse.com/how-delete-discussion-threads-incorrect-url-disqus.html" target="_blank" rel="noopener">How to delete discussion threads with incorrect URL in Disqus</a></li><li><a href="https://xuanwo.io/2018/10/15/revocer-lost-blog-comments/" target="_blank" rel="noopener">恢复博客遗失的评论</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍了 Disqus 提供的评论迁移工具之一，URL Mapper 的使用方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://printempw.github.io/categories/tech/"/>
    
    
      <category term="博客" scheme="https://printempw.github.io/tag/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="Disqus" scheme="https://printempw.github.io/tag/Disqus/"/>
    
  </entry>
  
  <entry>
    <title>博客更新报告：2019 年的第一篇博文</title>
    <link href="https://printempw.github.io/first-post-of-2019/"/>
    <id>https://printempw.github.io/first-post-of-2019/</id>
    <published>2019-09-22T21:00:00.000Z</published>
    <updated>2019-09-22T21:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>哎呀你看，这人博客草都长三米高了耶！博主好摸哦！</p><hr><p>好久不见。各位最近过得怎么样？我还是老样子，忙。又摸又忙。</p><p>大概从去年年底开始到最近几个月，我在某个项目（大概能算是项目吧？）上投注了大量的时间和精力，以至于基本没有时间顾及这边的东西。从我的 GitHub 格子就可以很直观地看出来，我这一年实属摸得透彻。</p><p><img src="https://img.blessing.studio/images/2019/09/23/github-activities-2018-now.png" srcset="/images/loading.jpg" data-srcset="https://img.blessing.studio/images/2019/09/23/github-activities-2018-now.png" alt="github-activities-2018-now"></p><p>至于在忙什么，等到以后能公开的时候我会写一篇博客聊一聊的。</p><p>回到正题。这次久违的博文主要是报告一下博客的变化。<strong>没错，我终于换主题啦！</strong></p><a id="more"></a><p>以前的读者们可能还有印象，自从我开始写博客的这几年来，主题一直都没变过。</p><p>Seventeen 原本是一个付费的 WordPress 主题，其漂亮的外观让当时还是建站萌新的我就对它一见钟情。之后不论是 <a href="https://printempw.github.io/hello-ghost-goodbye-wordpress/">迁移至 Ghost</a>，还是 <a href="https://printempw.github.io/migrated-to-hexo/">迁移至 Hexo</a>，我都把它移植到了相应的平台。（至今为止有很多人找我问过这个主题，但毕竟原本是付费的，原作者也早就已经停止了贩卖，所以我不能把它分享出来。<del>说实话我也联系不上原作者了</del>）</p><p>修修补补，数经风雨，它就这么陪伴了我四年时光。</p><p>但我寻思看了这么久也审美疲劳，所以还是换一个吧！（气氛毁灭者）</p><p>之前我就一直想写一个自己的主题，所以就趁这次恢复更新的机会捣鼓了一个出来。风格是我喜欢的极简风，双栏布局，整体以文字为主，不添加过多的修饰元素，在排版上也下了不少功夫。</p><p>在 Accent Color 的选取上，本来想直接用我最喜欢的颜色 <a href="https://irocore.com/fujimurasaki/" target="_blank" rel="noopener">藤紫色</a> (#8F82BC) 的，但作为主色可能还是有点偏淡，所以选择了稍深一点的 <a href="https://irocore.com/sumire-iro/" target="_blank" rel="noopener">菫色</a> (#7065A3)。而主题也因此得名：<ruby>紫<rp>(</rp><rt>murasaki</rt><rp>)</rp></ruby>。</p><blockquote><p>代码照例以 MIT 协议开源在 GitHub 上：<a href="https://github.com/printempw/hexo-theme-murasaki/" target="_blank" rel="noopener">printempw/hexo-theme-murasaki</a></p></blockquote><p>不过毕竟是周末两天时间写出来的，还有非常多不完善的地方，只是因为没时间了所以先糊了上去，目前还不推荐各位使用（光是我自己的 TODO 就已经列了一大堆了，我真的有时间全实现吗……）。等到我觉得到了能发布的水准，我会专门写一篇关于这个主题的博客的，这里就按下不表咕咕咕。</p><p>其他主要的改动还有博客的标题与副标题，从「Blessing Studio - 半吊子全栈开发者的日常」更新为了「PRIN BLOG - 致我所深爱着的世界」。</p><p>也没啥特别的理由，真要说的话就是想表明我对生活的态度，以及我想在这浩如烟海的 Cyberworld 中留下点什么痕迹的愿望。还有就是看起来更装逼一点（</p><p>因为博客改名了，原来的域名 <a href="https://blessing.studio" target="_blank" rel="noopener">blessing.studio</a> 也就一起 deprecated 掉了，目前是 301 重定向到当前的域名 <a href="https://printempw.github.io">printempw.github.io</a> 上。对，就是 GitHub Pages 的默认域名。虽然没那么个性，但不用担心过期失效，所以普普通通的也挺好。</p><p>另外我还买了个域名 <a href="https://printem.pw" target="_blank" rel="noopener">printem.pw</a> 指向这里，虽然不会作为主域名，不过放到外面个人资料之类的地方也还是蛮拉风的。</p><hr><p>时间不早了，这次就先写到这里吧。其实我还有好多好多想写的东西，TODO 和草稿箱里也存了快一年份的草稿与话题，就是不知道什么时候能有时间写咯。</p><p>最后放张原来的截图留念：</p><p><img src="https://img.blessing.studio/images/2019/09/23/seventeen-theme-screenshot-2019.png" srcset="/images/loading.jpg" data-srcset="https://img.blessing.studio/images/2019/09/23/seventeen-theme-screenshot-2019.png" alt="seventeen-theme-screenshot-2019"></p><p>哦对，博客内容的许可协议也从 CC BY-NC-SA 3.0 改成了 CC BY 4.0。虽然不会有什么实质上的变化而且还更宽松了，姑且还是提醒一下。👇</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;哎呀你看，这人博客草都长三米高了耶！博主好摸哦！&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;好久不见。各位最近过得怎么样？我还是老样子，忙。又摸又忙。&lt;/p&gt;
&lt;p&gt;大概从去年年底开始到最近几个月，我在某个项目（大概能算是项目吧？）上投注了大量的时间和精力，以至于基本没有时间顾及这边的东西。从我的 GitHub 格子就可以很直观地看出来，我这一年实属摸得透彻。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.blessing.studio/images/2019/09/23/github-activities-2018-now.png&quot; srcset=&quot;/images/loading.jpg&quot; data-srcset=&quot;https://img.blessing.studio/images/2019/09/23/github-activities-2018-now.png&quot; alt=&quot;github-activities-2018-now&quot;&gt;&lt;/p&gt;
&lt;p&gt;至于在忙什么，等到以后能公开的时候我会写一篇博客聊一聊的。&lt;/p&gt;
&lt;p&gt;回到正题。这次久违的博文主要是报告一下博客的变化。&lt;strong&gt;没错，我终于换主题啦！&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="日常" scheme="https://printempw.github.io/categories/diary/"/>
    
    
      <category term="博客" scheme="https://printempw.github.io/tag/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="水" scheme="https://printempw.github.io/tag/%E6%B0%B4/"/>
    
  </entry>
  
  <entry>
    <title>为 Hexo 博客添加隐藏文章功能</title>
    <link href="https://printempw.github.io/hexo-plugin-to-make-posts-sage-unlisted/"/>
    <id>https://printempw.github.io/hexo-plugin-to-make-posts-sage-unlisted/</id>
    <published>2018-11-14T15:33:30.000Z</published>
    <updated>2019-11-30T08:25:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>更新：咕了一万年之后插件终于更新了，从 <code>hexo-sage-posts</code> 更名为 <code>hexo-hide-posts</code>，修复了「上一篇 / 下一篇文章」暴露隐藏文章入口的问题，添加了 <code>hidden:list</code> 命令，另外用了点小 hack，支持自动向隐藏文章页面插入 <code>noindex</code> 标签防止搜索引擎收录。</p></blockquote><p>隐藏博客中某些特定的文章应该算是一个比较常见的需求，毕竟谁都有些不希望让别人看到的东西。当然啦，你可能会说，「不想被看到就不要放到博客上来嘛」。话是没错，不过有时候人就是这么别扭，想让某些文章被看到，却又不想被所有人看到，又或者是某些文章只想和自己熟悉的人一起分享。</p><a id="more"></a><p>于是我写了一个 Hexo 插件 <strong><a href="https://github.com/printempw/hexo-hide-posts" target="_blank" rel="noopener">hexo-hide-posts</a></strong> 来实现这个需求（网上也有一些关于 Hexo 隐藏文章的教程，不过一般都要求修改主题文件，还是我这样写个插件更通用一些）。它的功能如下：</p><ul><li>在博客的所有文章列表中隐藏指定的文章（包括首页、存档页、分类标签、Feed 等）；</li><li>被隐藏的文章依然可以通过文章链接直接访问（比如 <code>https://hexo.example/{slug}/</code>）；</li><li>除非知道链接，任何人都无法找到这些被隐藏的文章。</li></ul><p>如果你用过 YouTube，应该会比较容易理解这一套逻辑。当一个 YouTube 视频被设定为 <strong><a href="https://support.google.com/youtube/answer/157177" target="_blank" rel="noopener">限定公開</a></strong>（这是日文的译文，我觉得这个比较贴切。中文译作「不公开」，英文为 Unlisted）时，这个视频就是 <strong>只有知道链接的人才能访问</strong>，既不会显示在频道中也不会被搜索到。本插件就是借鉴<del>抄袭</del>的这个功能。</p><p><del>另外，插件名中的 <a href="https://knowyourmeme.com/memes/sage" target="_blank" rel="noopener">sage</a> 这个单词，混过匿名版（A 岛、K 岛以及各种 futaba 贴图版）的同学可能会比较熟悉。Sage 词源为日文中的 <strong>下げ</strong>（さげ，降低、下沉），回复讨论串时在 E-mail 栏填入这个单词可以避免该串被顶起（上げ，上浮）。虽然这和本插件的功能并不一致，但我还是借用了这个名称，纯粹是脑子一热，没什么特别的理由。（笑）</del></p><p>插件的具体使用方法都写在 README 里了，这里就不再赘述。安装插件后，在想要隐藏的文章的 front-matter（就是 Markdown 顶上的那个参数块）里添加一行 <code>hidden: true</code> 即可。</p><p>至于插件的原理嘛，简单来说就是在 Hexo 运行 <a href="https://hexo.io/zh-cn/api/generator.html" target="_blank" rel="noopener">generator</a> 之前修改储存所有文章的变量 <code>hexo.locals.posts</code>，从中排除掉被标记为 <code>hidden: true</code> 的文章，这样所有的 generator（用于生成首页、存档页、Feed 等）都会直接忽略掉这些文章。接下来我们覆写了原来的 <code>post</code> generator（它用于生成具体的文章页面），让它能正常处理那些被隐藏的文章。这样的结果就是，<code>post</code> generator 会帮我们生成具体的文章页面（即 <code>public/{slug}/index.html</code>），但是其他所有的页面中都不会包含这篇文章，除非你手动在其他文章中添加了该文章的链接。</p><p>对具体实现有兴趣的话可以直接去看插件源码，注释我也写得蛮详细的（不如说注释都要比源码多了）。另外，还是要再吐槽一下 Hexo 的辣鸡文档（上一次吐槽是 <a href="https://printempw.github.io/get-hexo-posts-by-category-or-tag/">移植主题</a> 的时候），为了写这个插件我基本上把 Hexo 的源码都翻了一遍，绝了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;更新：咕了一万年之后插件终于更新了，从 &lt;code&gt;hexo-sage-posts&lt;/code&gt; 更名为 &lt;code&gt;hexo-hide-posts&lt;/code&gt;，修复了「上一篇 / 下一篇文章」暴露隐藏文章入口的问题，添加了 &lt;code&gt;hidden:list&lt;/code&gt; 命令，另外用了点小 hack，支持自动向隐藏文章页面插入 &lt;code&gt;noindex&lt;/code&gt; 标签防止搜索引擎收录。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;隐藏博客中某些特定的文章应该算是一个比较常见的需求，毕竟谁都有些不希望让别人看到的东西。当然啦，你可能会说，「不想被看到就不要放到博客上来嘛」。话是没错，不过有时候人就是这么别扭，想让某些文章被看到，却又不想被所有人看到，又或者是某些文章只想和自己熟悉的人一起分享。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://printempw.github.io/categories/tech/"/>
    
    
      <category term="博客" scheme="https://printempw.github.io/tag/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="JavaScript" scheme="https://printempw.github.io/tag/JavaScript/"/>
    
      <category term="Hexo" scheme="https://printempw.github.io/tag/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Windows 下手动搭建 PHP + Nginx/Apache 开发环境</title>
    <link href="https://printempw.github.io/setup-nginx-php-on-windows/"/>
    <id>https://printempw.github.io/setup-nginx-php-on-windows/</id>
    <published>2018-11-01T15:00:10.000Z</published>
    <updated>2020-03-03T13:37:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>看到这个标题，有人可能会想吐槽：</p><p><strong>你他娘的写了这么久 PHP，怎么现在想起来搭建开发环境了？</strong></p><p>呃，情况呢是这么个情况，我之前开发的那个 PHP 项目 (<a href="https://github.com/printempw/blessing-skin-server/" target="_blank" rel="noopener">printempw/blessing-skin-server</a>) 在两个月前发布 v3.5.0 版本后基本就已经告一段落了。虽然我本意是不再更新<del>（弃坑的委婉说法）</del>，因为当前的版本已经足够完善，该有的东西都有了（而且说实话搞了这么久我也腻味，不仅是对这个程序，还有对国内 Minecraft 开发生态以及用户群体的失望）。</p><p>不过我的朋友 <a href="https://blog.gplane.win/" target="_blank" rel="noopener">g-plane</a> 说他愿意接坑，所以现在这个项目的后续开发都是他在搞。而我也乐得清闲，做个甩手掌柜 <a href="https://blessing.studio/vscode-c-cpp-configuration-for-acm-oj/" target="_blank" rel="noopener">搞别的</a> 去了。当我摸鱼正快活时，他过来联系我说准备发布 4.0.0-alpha 了，我才想起来这茬：「啊，我连新版本长啥样都还不知道呢！😂」于是急急忙忙 pull 了新代码准备 review 一下，却发现我的新笔电上甚至压根儿就没安装 PHP 开发环境，只能说是非常地真实。</p><a id="more"></a><p>因为 <a href="https://blessing.studio/phpstudy-prober-page-502-bad-gateway/" target="_blank" rel="noopener">某些原因</a>，我不想继续使用那些 PHP 一键包来搭建开发环境了，所以这次我打算全部自己来。本文记录了我手动安装配置 PHP + Nginx/Apache 开发环境的过程，希望能帮到后来人。</p><p>注意，本文中的配置适用于本地开发环境，应用至生产环境时要注意哦。</p><blockquote><p><strong>2020/03/03 更新</strong>：</p><p>你也可以直接用 scoop 来管理 WNMP 开发环境。</p><p>安装：</p><pre><code class="cmd">scoop install nginx mariadb php</code></pre><p>启动：</p><pre><code class="cmd">nginx -p %NGINX_HOME%mysqld --standalonephp-cgi -b 127.0.0.1:9000</code></pre><p>配置或数据文件的位置：</p><pre><code class="plain">C:\Users\printempw\scoop\apps\nginx\current\confC:\Users\printempw\scoop\apps\mariadb\current\dataC:\Users\printempw\scoop\apps\php\current\cli</code></pre><p>比起手动下载方便不少。</p></blockquote><h2 id="0x01-安装-Nginx-Apache"><a href="#0x01-安装-Nginx-Apache" class="headerlink" title="0x01 安装 Nginx / Apache"></a>0x01 安装 Nginx / Apache</h2><p><strong>如果你用的是 Nginx：</strong></p><ul><li>去 <a href="https://nginx.org/en/download.html" target="_blank" rel="noopener">官网</a> 下载 Windows 版的 Nginx（我下载的是 <code>nginx-1.14.0.zip</code>）；</li><li>解压至你喜欢的地方（我放在 <code>E:\environment\nginx</code> 里）；</li><li>直接双击运行 <code>nginx.exe</code>；</li><li>如果能正常访问 <code>http://localhost:80</code>，就可以进行下一步了。</li></ul><p>推荐修改的 <code>nginx.conf</code> 配置如下：</p><pre><code class="nginx"># 可以适当调高，但不要超过 CPU 核心数量worker_processes  4;events {    # 开发环境下不用太考虑 worker 最大并发连接数    worker_connections  1024;}http {    include       mime.types;    default_type  application/octet-stream;    sendfile      on;    keepalive_timeout 65;    # 启用 gzip    gzip on;    gzip_disable &quot;MSIE [1-6].(?!.*SV1)&quot;;    gzip_http_version 1.1;    gzip_vary on;    gzip_proxied any;    gzip_min_length 1000;    gzip_buffers 16 8k;    gzip_comp_level 6;    gzip_types text/plain text/css text/xml text/javascript application/json application/x-javascript application/xml application/xml+rss;    # 这里面的内容等 0x03 再细说    include vhosts.conf;}</code></pre><p><strong>如果你用的是 Apache：</strong></p><ul><li>因为 Apache 官网并不提供 Windows 版的构建下载，所以需要去 <a href="https://www.apachelounge.com/download/" target="_blank" rel="noopener">Apache Lounge</a> 或者其他 <a href="https://httpd.apache.org/docs/current/platform/windows.html#down" target="_blank" rel="noopener">官方推荐的站点</a> 下载预编译二进制包（我下载的是 <code>httpd-2.4.37-win64-VC15.zip</code>，你愿意的话也可以自己编译）；</li><li>解压至你喜欢的地方（我放在 <code>E:\environment\apache</code> 里）；</li><li>直接双击运行 <code>bin/httpd.exe</code>；</li><li>如果能正常访问 <code>http://localhost:80</code>，就可以进行下一步了。</li></ul><p>推荐修改的 <code>httpd.conf</code> 配置如下：</p><pre><code class="apache"># 修改为你的安装目录Define SRVROOT &quot;E:\environment\apache&quot;ServerRoot &quot;${SRVROOT}&quot;Listen 80ServerName localhost# 按需启用模块LoadModule rewrite_module modules/mod_rewrite.soLoadModule ...# 推荐注释掉自带的 DocumentRoot 和 &lt;Directory&gt;# 这里面的内容等 0x03 再细说Include conf/extra/httpd-php.confInclude conf/vhosts.conf</code></pre><h2 id="0x02-安装-PHP"><a href="#0x02-安装-PHP" class="headerlink" title="0x02 安装 PHP"></a>0x02 安装 PHP</h2><p>Windows 版 PHP 下载地址：</p><p><a href="https://windows.php.net/download" target="_blank" rel="noopener">https://windows.php.net/download</a></p><p>其中有 NTS（Non Thread Safe，非线程安全）和 TS（Thread Safe，线程安全）两种版本，简单来说就是 <strong>Nginx 用 NTS 版，Apache 通常用 TS 版</strong>（也可以用 NTS），它们之间的具体区别有兴趣的话可以自己去了解一下。</p><p>为了同时兼容 Nginx 与 Apache，本文将以 NTS 版为例进行配置。</p><ul><li>下载合适的版本（我下载的是 <code>php-7.2.11-nts-Win32-VC15-x64.zip</code>）；</li><li>解压至你喜欢的位置（我放在 <code>E:\environment\php</code> 里）；</li><li>复制一份 <code>php.ini-development</code>，重命名为 <code>php.ini</code> 并适当修改其中配置；</li><li>直接双击运行 <code>php.exe</code>；</li><li>如果能正常打开 PHP Interactive Shell，就可以进入下一步了。</li></ul><p><strong>如果无法运行，请检查你是否安装了对应的 VC 运行库。</strong></p><p>推荐修改的 <code>php.ini</code> 配置如下：</p><pre><code class="ini">; 扩展所在的目录，自行修改extension_dir = &quot;E:\environment\php\ext&quot;; 按自己的需求启用扩展extension=pdo_mysqlextension=...; 各种缓存的位置sys_temp_dir = &quot;E:\environment\php\temp&quot;upload_tmp_dir = &quot;E:\environment\php\temp&quot;session.save_path = &quot;E:\environment\php\temp&quot;; 其他杂七杂八的upload_max_filesize = 100Mdate.timezone = Asia/Shanghai</code></pre><h2 id="0x03-配置-FastCGI-转发"><a href="#0x03-配置-FastCGI-转发" class="headerlink" title="0x03 配置 FastCGI 转发"></a>0x03 配置 FastCGI 转发</h2><p>接下来才是重头戏，我们要让 Web Server 与 PHP 能够互相通信以完成请求。</p><p>作为 Web Server 的后端时，PHP 主要有两种运行方式，一种是 <strong>独立进程、使用 <a href="http://www.nowamagic.net/librarys/veda/detail/1319" target="_blank" rel="noopener">FastCGI 协议</a> 与 Web Server 通信</strong>（Nginx 用的就是这种），另外一种是 <strong>作为模块直接加载到 Web Server 中</strong>（比如 Apache 的 <code>mod_php</code> 模块，不过 Apache 也支持 FastCGI 方式）。详细的原理我就不介绍了，有兴趣的选手可以去了解一下。</p><p>为了能够同时兼容 Nginx 和 Apache，<strong>本文均使用 FastCGI 方式加载 PHP</strong>。</p><hr><p>首先我们需要配置一下 PHP 的 FastCGI 进程管理器。为什么呢？因为直接运行 PHP 的 FastCGI 进程（在 Windows 上就是 <code>php-cgi.exe</code>）有以下缺点：</p><ul><li>配置文件 <code>php.ini</code> 修改后无法平滑重载，需要重新启动 <code>php-cgi</code> 进程；</li><li>Windows 下 <code>php-cgi</code> 默认处理 500 个请求后就自动退出（<code>PHP_FCGI_MAX_REQUESTS</code>）；</li><li>如果因为其他原因造成 <code>php-cgi</code> 进程崩溃，就无法处理后续请求了。</li></ul><p>所以我们需要一个类似守护进程的东西，来保证始终有一定数量的 <code>php-cgi</code> 进程在运行。<a href="http://php.net/manual/zh/install.fpm.php" target="_blank" rel="noopener">PHP-FPM</a> (PHP FastCGI Process Manager) 是 PHP 官方钦定的 FastCGI 进程管理器，但遗憾的是，它只适用于类 Unix 系统。在 Windows 上，我们可以使用这些替代品来实现类似的功能（<strong>Apache 用户不需要配置这些东西</strong>，因为它的 <code>mod_fcgid</code> 模块自带 FastCGI 进程管理功能）：</p><ul><li><a href="https://github.com/78/xxfpm" target="_blank" rel="noopener">xxfpm</a></li><li><a href="https://github.com/deemru/php-cgi-spawner" target="_blank" rel="noopener">php-cgi-spawner</a></li><li><a href="https://github.com/lighttpd/spawn-fcgi" target="_blank" rel="noopener">spawn-fcgi</a></li></ul><p>本文将以 php-cgi-spawner 为例进行配置。</p><ul><li><p>在 <a href="https://github.com/deemru/php-cgi-spawner/releases" target="_blank" rel="noopener">这里</a> 下载编译好的 <code>php-cgi-spawner.exe</code>；</p></li><li><p>放到 PHP 的安装目录下（本文为 <code>E:\environment\php</code>）；</p></li><li><p>打开 PowerShell 或者 CMD，运行命令：</p><pre><code class="powershell"># 令 PHP FastCGI 处理程序监听在 9000 端口上# 至少开启 4 个 php-cgi 进程，高负载时最多可以开到 16 个.\php-cgi-spawner.exe &quot;php-cgi.exe -c php.ini&quot; 9000 4+16</code></pre></li><li><p>如果一切正常，你将可以在任务管理器中看到同时运行的多个 <code>php-cgi</code> 进程。</p></li></ul><p><img src="https://img.blessing.studio/images/2018/11/01/php-cgi-processes.png" srcset="/images/loading.jpg" data-srcset="https://img.blessing.studio/images/2018/11/01/php-cgi-processes.png" alt="php-cgi-processes"></p><p><strong>接下来修改 Nginx 配置</strong>（即 0x01 中提到的 <code>vhosts.conf</code> 中的内容），通过 FastCGI 协议将请求转发给监听在 9000 端口上的 PHP 进行处理：</p><pre><code class="nginx">server {    listen       80;    server_name  localhost;    root   E:/wwwroot;    index  index.html index.htm index.php;    location ~ [^/]\.php(/|$) {        # 从 URI 中分离出 $fastcgi_script_name 和 $fastcgi_path_info 的值        # 不推荐使用 php.ini 中的 cgi.fix_pathinfo 选项，这可能会造成安全隐患        # 虽然我感觉 8012 年了应该没人用 PATH_INFO 了……不需要的话去掉即可        fastcgi_split_path_info  ^(.+?\.php)(/.*)$;        fastcgi_param  PATH_INFO  $fastcgi_path_info;        # 当请求的 .php 文件不存在时直接返回 404        # 不然交给 PHP 处理的话那边就会返回 No input file specified.        if (!-f $document_root$fastcgi_script_name) {            return 404;        }        fastcgi_pass   127.0.0.1:9000;        fastcgi_index  index.php;        # 自带的配置文件，里面设置了一大堆 CGI 协议中的变量        include        fastcgi.conf;    }}</code></pre><hr><p><strong>Apache 用户不需要手动配置 PHP FastCGI 进程管理器，相对简单一些：</strong></p><ul><li>在上面提到的 <a href="https://www.apachelounge.com/download/" target="_blank" rel="noopener">Apache Lounge</a> 上下载编译好的 <code>mod_fcgid</code> 模块；</li><li>解压后，将 <code>mod_fcgid.so</code> 放入 Apache 的 <code>modules</code> 目录；</li><li>编辑配置文件加载模块（即 0x01 中提到的 <code>conf/extra/httpd-php.conf</code>）：</li></ul><pre><code class="apache"># 如果嫌麻烦的话这一段也可以直接放到 httpd.conf 里面去LoadModule fcgid_module modules/mod_fcgid.so&lt;IfModule fcgid_module&gt;FcgidInitialEnv PHPRC &quot;E:/environment/php/&quot;FcgidInitialEnv PHP_FCGI_MAX_REQUESTS 1000AddHandler fcgid-script .phpFcgidWrapper &quot;E:/environment/php/php-cgi.exe&quot; .phpFcgidIOTimeout 384FcgidConnectTimeout 360FcgidOutputBufferSize 128FcgidMaxRequestsPerProcess 1000FcgidMinProcessesPerClass 0FcgidMaxProcesses 16FcgidMaxRequestLen 268435456ProcessLifeTime 360&lt;/IfModule&gt;</code></pre><ul><li>编辑 <code>conf/vhosts.conf</code> 允许运行 CGI 程序：</li></ul><pre><code class="apache">&lt;VirtualHost localhost:80&gt;  DocumentRoot &quot;E:\wwwroot&quot;  &lt;Directory &quot;E:\wwwroot&quot;&gt;    DirectoryIndex index.html index.php    # 注意这里的 +ExecCGI，不加的话会 403    Options -Indexes -FollowSymLinks +ExecCGI    AllowOverride All    Order allow,deny    Allow from all    Require all granted  &lt;/Directory&gt;&lt;/VirtualHost&gt;</code></pre><p>如果一切配置正确，你应该就能正常访问 PHP 网页了。</p><p><img src="https://img.blessing.studio/images/2018/11/01/nginx-php-works.png" srcset="/images/loading.jpg" data-srcset="https://img.blessing.studio/images/2018/11/01/nginx-php-works.png" alt="nginx-php-works"></p><h2 id="0x04-编写启停脚本"><a href="#0x04-编写启停脚本" class="headerlink" title="0x04 编写启停脚本"></a>0x04 编写启停脚本</h2><p>虽然整个系统是跑起来了，但总不能每次启动都得开一大堆控制台窗口吧？弄个小工具管理 Nginx/Apache 和 PHP 的进程还是很有必要的。各种一键包中一般都自带了方便好用的界面来管理这些进程，不过既然我们选择了手动配置，那这一块也得我们自己搞定了。因为图方便，我选择使用 Windows 的批处理脚本（Batch File）来完成这项需求，保存为 <code>.bat</code> 文件双击运行就完事儿了。</p><p><strong>启动 Nginx 和 PHP：</strong></p><pre><code class="cmd">@ECHO OFFset nginx_home=..\nginxset php_home=..\phpECHO Starting PHP FastCGI....\RunHiddenConsole.exe %php_home%\php-cgi-spawner.exe &quot;%php_home%\php-cgi.exe -c %php_home%\php.ini&quot; 9000 4+16ECHO Starting Nginx....\RunHiddenConsole.exe %nginx_home%\nginx.exe -p %nginx_home%</code></pre><p><strong>停止 Nginx 和 PHP：</strong></p><pre><code class="cmd">@ECHO OFFECHO Stopping nginx...taskkill /F /IM nginx.exe &gt; nulECHO Stopping PHP FastCGI...taskkill /F /IM php-cgi-spawner.exe &gt; nultaskkill /F /IM php-cgi.exe &gt; nul</code></pre><p><strong>重载 Nginx 配置：</strong></p><pre><code class="cmd">@ECHO OFFset nginx_home=..\nginxECHO Reloading Nginx...%nginx_home%\nginx.exe -s reload</code></pre><p><strong>启动 Apache</strong>（Apache 会帮我们启动 PHP 的）：</p><pre><code class="cmd">@ECHO OFFset apache_home=..\apacheECHO Starting Apache Httpd....\RunHiddenConsole.exe %apache_home%\bin\httpd.exe</code></pre><p><strong>停止 Apache：</strong></p><pre><code class="cmd">@ECHO OFFECHO Stopping Apache Httpd...taskkill /F /IM httpd.exe &gt; nul</code></pre><p>这些脚本我放在 <code>E:\environment\scripts</code> 目录中，如果你需要放在其他地方，请适当修改脚本中的可执行文件路径。另外，脚本中用到了 <code>RunHiddenConsole.exe</code> 来隐藏命令行窗口，你可以在 <a href="http://redmine.lighttpd.net/attachments/660/RunHiddenConsole.zip" target="_blank" rel="noopener">这里</a> 下载到这个小工具。</p><p><img src="https://img.blessing.studio/images/2018/11/01/wnmp-all-processes.png" srcset="/images/loading.jpg" data-srcset="https://img.blessing.studio/images/2018/11/01/wnmp-all-processes.png" alt="wnmp-all-processes"></p><h2 id="0x05-后记"><a href="#0x05-后记" class="headerlink" title="0x05 后记"></a>0x05 后记</h2><p>配置完成后的目录结构大概是这样的（有省略）：</p><pre><code class="text">E:\environment&gt; tree.├── apache│   ├── bin│   ├── cgi-bin│   ├── conf│   │   ├── extra│   │   ├── original│   │   ├── charset.conv│   │   ├── httpd.conf *│   │   ├── magic│   │   ├── mime.types│   │   ├── openssl.cnf│   │   └── vhosts.conf *│   ├── include│   ├── lib│   ├── logs│   └── modules├── mysql│   ├── bin│   ├── data│   ├── include│   ├── lib│   └── share├── nginx│   ├── conf│   │   ├── fastcgi.conf│   │   ├── fastcgi_params│   │   ├── koi-utf│   │   ├── koi-win│   │   ├── mime.types│   │   ├── nginx.conf *│   │   ├── scgi_params│   │   ├── uwsgi_params│   │   ├── vhosts.conf *│   │   └── win-utf│   ├── contrib│   ├── logs│   └── nginx.exe├── php│   ├── dev│   ├── ext│   ├── extras│   ├── lib│   ├── sasl2│   ├── temp│   ├── ...│   ├── php7.dll│   ├── php-cgi.exe│   ├── php-cgi-spawner.exe *│   ├── php.exe│   └── php.ini *└── scripts    ├── reload-nginx.bat    ├── restart-nginx.bat    ├── RunHiddenConsole.exe    ├── start-all.bat    ├── start-apache.bat    ├── start-mysql.bat    ├── start-nginx.bat    ├── stop-all.bat    ├── stop-apache.bat    ├── stop-mysql.bat    └── stop-nginx.bat</code></pre><p>非常清爽，有种一切尽在掌控中的感觉，我喜欢。</p><p>如果你是一名 PHP 开发者，却从来没有手动配置过 PHP 环境的话，那我建议你尝试一下。虽然生产环境上一般都是采用成熟的一键包，不过手动配置一下这一套东西可以更深入地了解 PHP 与 Web Server 的协作机制，这对于编写上层应用以及运维也是很有好处的。</p><p>本来想顺带凑齐一套 WNMP，但是 MySQL 的安装配置相对比较简单，而且也不像 PHP 与 Web Server 那样耦合紧密，所以这里就按下不表。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看到这个标题，有人可能会想吐槽：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你他娘的写了这么久 PHP，怎么现在想起来搭建开发环境了？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;呃，情况呢是这么个情况，我之前开发的那个 PHP 项目 (&lt;a href=&quot;https://github.com/printempw/blessing-skin-server/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;printempw/blessing-skin-server&lt;/a&gt;) 在两个月前发布 v3.5.0 版本后基本就已经告一段落了。虽然我本意是不再更新&lt;del&gt;（弃坑的委婉说法）&lt;/del&gt;，因为当前的版本已经足够完善，该有的东西都有了（而且说实话搞了这么久我也腻味，不仅是对这个程序，还有对国内 Minecraft 开发生态以及用户群体的失望）。&lt;/p&gt;
&lt;p&gt;不过我的朋友 &lt;a href=&quot;https://blog.gplane.win/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;g-plane&lt;/a&gt; 说他愿意接坑，所以现在这个项目的后续开发都是他在搞。而我也乐得清闲，做个甩手掌柜 &lt;a href=&quot;https://blessing.studio/vscode-c-cpp-configuration-for-acm-oj/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;搞别的&lt;/a&gt; 去了。当我摸鱼正快活时，他过来联系我说准备发布 4.0.0-alpha 了，我才想起来这茬：「啊，我连新版本长啥样都还不知道呢！😂」于是急急忙忙 pull 了新代码准备 review 一下，却发现我的新笔电上甚至压根儿就没安装 PHP 开发环境，只能说是非常地真实。&lt;/p&gt;
    
    </summary>
    
    
      <category term="技术" scheme="https://printempw.github.io/categories/tech/"/>
    
    
      <category term="Nginx" scheme="https://printempw.github.io/tag/Nginx/"/>
    
      <category term="PHP" scheme="https://printempw.github.io/tag/PHP/"/>
    
      <category term="Apache" scheme="https://printempw.github.io/tag/Apache/"/>
    
  </entry>
  
</feed>
